[{
    "title": "思路整理：对于 illumos 上 SO_REUSEPORT 补丁的笔记",
    "date": "",
    "description": "",
    "body": "把目前世界上能找到的最正统的 SysV 的源代码扒过来，对着它的网络栈一通搅合，还试图把改动作为补丁提交回去——这大概是我今年干出的事情里面最不知天高地厚的一件了。毕竟一头扎进有着数十年历史的代码堆里面本身就是需要勇气的一件事，更不用我改动的地方还有着炸掉世界各地的所有相关系统的潜力——在 IP 模块里面搞出个死锁干掉所有跑着的 illumos 系统这种事情想想就刺激。\n不过身为软件工程师，总得有梦想，而上面提到的那些心理障碍在让自己的代码跑在世界各地的服务器上的浪漫面前显然无足挂齿；所以四月的时候我还是头铁了上去，而且还真的搞出了一份 patch。截至本文成文之日，补丁仍在热烈 review 当中（显然，这种变动需要慎之又慎）；但我还是决定先花点时间，整理一下我自己的思路和所得，以方便后来者——包括以后的我自己。\n背景资料 illumos illumos 这个名字的认知度意外地不高——不少我见过的人都向我表示根本没听说过。不过如果我把它的前身拿出来，那恐怕是如雷贯耳：Solaris\n虽说 Solaris 这个名字的所有权现在处于 Oracle 手里，官方意义上的 OpenSolaris 项目也早已停止，但鉴于 illumos 社区内有大量的 Sun 前员工，而且 Oracle 已经事实上放弃了 Solaris，我觉得将 illumos 视作 Solaris 的正统后继而非 fork 没什么问题。\n考虑到如今 illumos 的知名度，以及 Solaris 身为正统 SysV 的名号，或许很多人会先入为主地认为这不过是个沉浸在自己旧日荣光之中的腐朽操作系统。\n远非如此。\n先不说基于 illumos 的 OpenIndiana 发行版作为 OpenSolaris 的二进制兼容物有其不可替代的应用场景这点，如今 illumos 的应用也远没到将死的程度—— 身为三星子公司的 joyent 目前仍然运行着由 SmartOS 支撑的云服务，且正积极地为 illumos 社区回馈贡献；我也时常能见到在线上运行着 OmniOS 服务器的管理员来到社区讨论（我自己也可算作其中一员：我在 Linode 上跑着一台 OmniOS VPS）。而社区的热度则可以从我挤满了未读消息的 IRC 和塞了几千封未读邮件的邮件列表中体现。\n相比于 Linux 这种主流 OS，illumos 确实小众；但这不代表它缺乏活力。而能为这样一个血统高贵（虽说 Unix 的血统不足惜）却又生机勃勃的 OS 贡献代码，不也是一种浪漫吗？\n题外话：“菜是原罪”风气流行的开源社区，在对待新人的态度上一贯没什么好风评（就我个人而言，对此我可以理解）；所以身为一个名不见经传还操着残废英语的萌新，在初进社区的时候我其实是做好了被喷个狗血淋头的心里准备的。\n完全没必要。illumos 社区里的友好和耐心简直令我感动。所以我在这里自愿地打个广告：如果有人希望为开源项目做点贡献的话，考虑一下 illumos 如何？从 bite-size bug 到各种高端变动，总有一款适合你。\nSO_REUSEPORT SO_REUSEPORT 这个选项最早引入于 Linux 2.9。该选项可以为 TCP 和 UDP socket 提供一套内核负载均衡功能：多个 socket 可以绑定到同一个 IP 地址上，而内核会将新入连接/数据在各个 socket 间分发。这个选项对于多进程服务器（例如 nginx）有着相当大的意义：进程之间的负载均衡可以被转交给内核处理，而无需上层应用再实现一个 accept 锁；并且惊群问题可以得到更为优雅及彻底的解决（因为新入连接在内核网络栈里就已经被分配到特定进程了，所以从一开始就不会唤醒所有进程）。\nDragonflyBSD 随后也跟进了这个变动，其实现语义与 Linux 基本一致，不过我听说在监听 socket 数量变化的时候略有不同：Dragonfly 上增加或者减少监听的 socket 的时候不会产生 reset（这点我没亲自测试）。\nFreeBSD 则在版本11引入了这个选项，但将选项名改成了 SO_REUSEPORT_LB。其理由主要有二：一是 FreeBSD 社区认为 Linux 的行为是在滥用 SO_REUSEPORT 的语义（毕竟 FreeBSD 一贯有点学院派作风），二是该平台上本来就有了 SO_REUSEPORT 选项，所以通过改名增加新选项来保持原选项的行为一致性。\n就我个人而言，其实我觉得 FreeBSD 的做法从理论层面上更为优雅；但我们毕竟不是真空中的球形鸡。Linux 的现有语义的接受度显然广泛得多，而且 Solaris/illumos 上原本并没有 SO_REUSEPORT 选项，所以也不存在破坏向前兼容性的问题。因而在社区内讨论过后，我们决定跟从 Linux 的命名。\n动手之前：明确需求 在动手做事情之前，我们首先需要明确到底该做什么——这听起来像是废话，但却经常被人忘掉（软件工程上尤其如此）。所以在真正动手写代码之前，我们先要明确选项的语义。\n不幸地，“明确语义”从来都不是 Linux 所擅长的东西：原 commit 中不仅提交信息语焉不详，代码中也没几行注释；虽说 \u0026ldquo;Good Code Documents Itself\u0026rdquo;，但 Linux 的网络栈显然还没达到这里的 Good Code 的程度，而且有些背景信息毕竟不是能从代码上一眼看出来的。但无论如何，we are where we are，所以不足的部分只好我们自己写程序测出来。\n具体的测试代码我就不展示了（过于 trivial，读者应当有能力根据我的描述自行实现），总之我整理出来的语义如下：\n 共通  若要允许复用，绑定到同一地址的每个 socket 都要在 bind() 之前开启该选项；在 bind() 之后再开启该选项不会生效。 关闭选项同理：在 bind() 之后再关闭该选项并不阻止其他 socket 绑定到同一地址，也不会让该 socket 不再接受负载均衡派发来的连接。 SO_REUSEPORT 并不隐含 SO_REUSEADDR。二者虽然语义类似但是行为不会互相影响。   TCP  在某一地址上绑定的 socket 数量发生变化（新 socket 绑定，或旧 socket 停止监听）时，各个平台对于半开连接的处理行为不同（我没仔细测试）：  Linux 在两种情况下都有可能对半开连接产生 RST。原因我没深究，不过 commit message 里提了一句，似乎是共享数据结构产生的问题。 DragonflyBSD 上据称两种情况都不会产生 RST。我没测试。 FreeBSD 上新 socket 绑定的情况我没测试，不过关闭旧 socket 的时候会有部分半开连接被 RST。     UDP Unicast  之前 SO_REUSEADDR 同样允许多个 socket 绑定到同一个地址上，但没有负载均衡行为：所有的新入数据都由新绑定的 socket 接收。SO_REUSEPORT 与该选项语义有重叠，但允许负载均衡。二者都打开的时候呢？Linux 没提，我测试的结论是依然会有负载均衡行为。 因为负载均衡通过对 IP 四元组取 hash 决定接收者，所以在绑定的 socket 恒定的情况下，特定地址发来的信息总会被转发到同一客户端上。我不确定该行为是否有保证（也不觉得应当依赖于这个行为），但至少在目前所有的 Linux 版本上都适用。   UDP Multicast/Broadcast  原 commit 完全没提多播/广播情况下的处理。测试结论是 SO_REUSEPORT 此时行为和 SO_REUSEADDR 一致：所有 socket 都会收到一份数据的拷贝。   其他协议  截至本文发布时，其他协议全部不支持该选项。    当然以上的结论里面其实漏掉了一个 corner case：若 SO_REUSEPORT 和 SO_REUSEADDR 同时在 UDP socket 上开启，但 bind() 时 SO_REUSEPORT 理当失败而 SO_REUSEADDR 理当成功（例如，新 socket 与现有 socket 所属进程具有的 effective UID 不同，或者复用连接数达到了 SO_REUSEPORT 允许的上限），那么绑定应当成功还是失败？但这个情况实在过于牛角尖，而且定义这个行为的收益实在太少（什么情况下会有人需要依赖这个行为？），再加上或许这里保持 flexible 反而更有利于未来的进一步实现，所以我决定不测试也不明确这个行为。\n明白了我们要做什么之后，来看看我们手上现有的东西：\n动手之前：底层架构 Solaris 的网络接口，以及 TLI illumos 脱胎于 OpenSolaris，而后者脱胎于 Solaris 10。Solaris 10 的 FireEngine 网络栈实现也就一直保留到了现有的 illumos 代码。\n具体的网络栈实现在《Solaris Internals: Solaris 10 and OpenSolaris Kernel Architecture》一书中有详细的剖析，而且仔细分析网络栈实现远超本文的涵盖范围，所以这里我不会讲得太详细，只稍微提几句，好让读者诸君有个概念。（不过其实那本书还挺难买：英文原版我只能搞到一本二手的，好在品相不错。）\n与 BSD 系的 Unix 不同，身为 SysV 系操作系统（而且大概最正统的 SysV）的 Solaris，其网络栈的原生 API 并非 BSD socket，而是基于 STREAMS 的 TLI (Transport Layer Interface) API；而在 VFS 层面上则通过一个 sockfs 模块将用户程序的 BSD socket 调用转发到 TLI 层面上的调用。\n从理论层面上来说 STREAMS 其实算是个比较先进的模型：每个连接都至少有一个 STREAM 头以及一个底层设备，STREAM 头对接用户程序，而底层设备对接网卡驱动；在二者之间可以动态插入多个 STREAM 模块以构成一个 STREAM 链，该链中每个模块都有单独的读队列及写队列，以此与其相邻的模块“首尾相接”。故一个典型的 TCP 连接应当具有这样的结构：\ngraph TD; A[\"STREAM 头\"] -- |写| B[\"TCP 协议实现\"] -- |写| C[\"IP 协议实现\"] -- |写| D[\"STREAM 底层设备\"]; D -- |读| C -- |读| B -- |读| A;  这结构理论上更符合 OSI 的七层模型，在刚出来之时用着也还不错；动态构建 STREAM 链确实开销较大，但在 Web 时代之前大部分连接都是长连接，所以平均下来这点开销基本可以忽略。\n在 Web 时代之前。\nWeb 时代的到来使得情况发生了巨大转变：之前的连接主要为长连接的假设不再成立，大部分 HTTP 连接都是高频短连接；这点使得 STREAMS 创建连接成本较高的缺点逐渐凸显。\n我们需要换个做法。\nSolaris 10 的 FireEngine Solaris 10 引入了一套重新实现的网络栈：FireEngine。\n即使以今天的眼光来看，FireEngine 的架构也相当先进。和不少操作系统上的网络实现不同，FireEngine 是完全并行化的：所有连接都可以并行处理，无关连接之间几乎不会产生干扰。\n另外，为了解决创建连接成本较高的问题，整个 TCP\u0026amp;UDP/IP 网络栈都被整合成了一个 STREAM 模块，上可直接接 STREAM 头，下可直接接底层设备。因为不需要再动态组装 STREAM 链，创建连接的效率被大幅提高了。\n至于并行化，则通过如下的机制实现：\n引入 squeue 作为同步机制；每个 squeue 与 CPU 绑定，而每个连接则与 squeue 绑定。此机制用来保证线程对连接的独占访问，以及提升数据的本地关联性。\nsqueue 实现于 TCP/IP 模块内，但并非只保护 TCP/IP 模块本身，而是保护从 ipclassifier 到 sockfs 的整个链路——换言之，数据包从 ipclassifier 出来之后，到达用户程序的所有路径都通过同一个机制同步。\n对于 TCP 连接，调整了 TCP 握手的处理方式：FireEngine 的实现在接收到 SYN 时会立即创建一个新的 TCP 连接（称为 eager），之后剩余的握手过程全部都在 eager 的回路中处理，而非在监听的 socket 上处理。\n在连接与网卡驱动之间的部分是 ipclassifier，其作用是将数据包分发到对应的 squeue 中供连接处理。几乎只有这部分涉及跨 CPU 数据传递（将数据包从接收中断的 CPU 发送到对应连接所绑定的 CPU）。\n这套设计使得 FireEngine 在架构上就实现了并行化，而无需在实现时再使用大量同步原语搞奇技淫巧。更棒的是，这种在早期便将数据包 fanout 上对应连接的设计正适合实现 SO_REUSEPORT。\n动手之前：现有成果 在正式动手之前，我们还有最后一步要做：看看前人都为我们留下了些什么。\n其实 illumos 上的 SO_REUSEPORT 实现并非是我从零开始写就的。joyent 在 几年前就已经引入了基本的 SO_REUSEPORT 支持12，目的是让 LX-Branded Zones （也即 Solaris 的 Linux 二进制兼容层）中的程序在使用 SO_REUSEPORT 的时候不至于直接炸掉。当然也因为如此，所以他们只实现了最最基本的行为；负载均衡语义则完全没有实现。\n不过无论如何，这两个补丁还是给我们打下了一个可以着手的基础，以及指明了修改的方向。所以作为正式分析我们自己的补丁之前的最后一步，我们还要仔细看看这两个提交。提交的源码和变动我不会直接贴在下面，所以请读者准备好浏览器窗口。\n tcp.h, tcp_impl.h  一点经验：读 C 代码的时候先看头文件总没错，因为这里是定义数据结构和接口的地方。\n这点对于我们正讨论的几个提交也适用。这两个头文件的主要变动无非两点：\n 定义struct tcp_rg_s，用于表示由绑定在同一个地址上的所有tcp_t（表示一个 TCP 连接的数据结构）组成的 group，以此建立在这些tcp_t之间的关联；以及该结构相关的函数接口。 往tcp_t里增加一个tcp_rg_bind引用，指向其所属的strut tcp_rg_s组。  意义一目了然，我不做过多解释。\n tcp_opt_data.c  该文件负责实现 setsockopt 的底层操作，所以也是新选项在执行过程中最先碰到的变动所在。注意两个 commit 中都有对该文件的变动。\n此处我们增加的操作全都是关于 SO_REUSEPORT 的行为。具体如下：\n 检查给定 socket 是否已经 fallback 到了 STREAMS。如果是，拒绝开启选项（fallback 到 STREAMS 的 socket 不支持该行为）。 如果是开启选项，那么在此时分配初始struct tcp_rg_s。我们之后在bind中里将会使用tcp_rg_bind的值决定是否允许重用，而非使用现有 socket 的选项值，这是因为在绑定 socket 之后再关闭该选项不应当阻止重用的可能。 如果是关闭选项，那么进行一系列检查。这里的各种状态比较复杂，但总之都遵循一个原则：如果当前 group 会在解除绑定的时候被释放，那么这里保留 group；否则释放 group。  这里因为我们提前分配了tcp_rg_bind组，导致状态检查有些复杂。不过没关系，总之我们先接着往下看。\n tcp_bind.c  这里的改动看上去很多，不过其实不可怕。大部分的变动都是tcp_rg_*族函数的实现，用于操作struct tcp_rg_s；真正对网络栈的改动其实无非如此：\n在bind时，若找到冲突的 socket，检查该 socket 是否属于某个tcp_rg_bind组。若是，则说明该冲突 socket 在绑定时开启了 SO_REUSEPORT，因此将我们的 socket 也加入这个组，并继续。否则正常返回 EADDRINUSE。\n ipclassifier.c  这里面的改动主要是将IPCL_HASH族宏替换成了等价的函数实现，并且在将 socket 从 hash 中移除的时候处理struct tcp_rg_s的释放。实质 trivial，相信读者能够自行理解。\n剩余的其他文件的改动一目了然，不必多言。\n正式下手 完成了以上的准备之后，我们需要做的工作便自然浮现了出来。整理一下便是：\n 将原本只适用于 TCP 的选项扩展到 UDP 上 实现负载均衡  这样看来其实剩下的工作并不多。至于是否真是如此，我们写写试试便可得知。\n选项适用范围扩展 原补丁中通过添加struct tcp_rg_s，并在tcp_t中添加相关引用实现了 TCP 上的 SO_REUSEPORT 选项支持；但显然，“绑定在同一地址上的一组 socket” 这个概念不仅仅适用于 TCP。要实现 UDP 上的支持，将这个概念扩展到 UDP 协议栈中似乎是个不错的着手点。\n实现这点最简单的办法，当然是直接复制一份代码到 UDP 的实现中，然而通往屎山的道路往往就由 C\u0026amp;P 式复用铺就，所以这显然不是好主意。更好的办法是把 TCP 和 UDP 连接放在同一个更高层的抽象之下，在这个抽象的层面上实现如今struct tcp_rg_s的概念。那么现在的网络栈中有没有合适的抽象呢？\n不难找。ipclassifier.h 里面定义了一个conn_t，从名称上就能猜出这个结构体表示的正是无关具体协议的“连接”这一概念。各处实现中对其的用法也能证实这点。\n此时我们的做法就很明确了：我们将struct tcp_rg_s的定义移到 ipclassifier.h 中（同时顺手将其改名为conn_rg_t以保持命名风格统一），然后将原本在tcp_t中的引用挪到conn_t中。原tcp_rg_*系列接口也做同样处理。\n下一步我们需要去 udp_opt_data.c 中为 UDP 增加相关选项的定义。一行改动即可解决。\n不过在大功告成之前，我们还有一件事情要处理：tcp_opt_data.c 中在开关选项是似乎有比较复杂的逻辑，这些逻辑是否在 UDP 上也有必要？\n要回答这个问题，我们首先需要分析这里的具体逻辑是什么。这里我觉得逐行分析大概会更清楚，所以我会把tcp_set_reuseport的所有代码全都贴过来。\n/* * Set a TCP connection\u0026#39;s participation in SO_REUSEPORT. This operation is * performed under the protection of the squeue via tcp_setsockopt. * The manipulation of tcp_rg_bind, as part of this operation, is subject to * these constraints: * 1. Prior to bind(), tcp_rg_bind can be set/cleared in tcp_set_reuseport * under the protection of the squeue. * 2. Once the connection has been bound, the tcp_rg_bind pointer must not be * altered until such time as tcp_free() cleans up the connection. * 3. A connection undergoing bind, which matches to a connection participating * in port-reuse, will switch its tcp_rg_bind pointer when it joins the * group of an existing connection in tcp_bindi(). */ 一上来我们就被砸了大段的逻辑解释。这里的注释主要说明的是对conn_rg_t进行操作时需要遵循的原则。具体而言：\n 在 socket 绑定之前，conn_rg_t可以随选项开关正常分配/去配。 一旦 socket 已被绑定，那么直到tcp_free()开始对连接数据进行清理为止，都不能再改动conn_rg_bind指针。这是因为 Linux 语义下 socket 绑定后再修改该选项并不阻止新的端口重用地址，而我们在绑定时判断是否重用的依据便是 conn_rg_bind 的值。 如果 socket 在绑定时找到了之前已经绑定的 socket，那么将其conn_rg_bind指针切换到现有的conn_rg_t。也即，这种情况下我们放弃已经分配的新组，而加入现有的组。  具体实现如下。\nstatic int tcp_set_reuseport(conn_t *connp, boolean_t do_enable) { tcp_t *tcp = connp-\u0026gt;conn_tcp; struct tcp_rg_s *rg; /* ... */ if (tcp-\u0026gt;tcp_state \u0026lt;= TCPS_CLOSED) { return (EINVAL); } 显然在已经关闭了的 TCP 连接上开启该选项毫无意义。\nif (connp-\u0026gt;conn_reuseport == 0 \u0026amp;\u0026amp; do_enable) { /* disabled -\u0026gt; enabled */ if (tcp-\u0026gt;tcp_rg_bind != NULL) { tcp_rg_setactive(tcp-\u0026gt;tcp_rg_bind, do_enable); } else { /* * Connection state is not a concern when initially * populating tcp_rg_bind. Setting it to non-NULL on a * bound or listening connection would only mean that * new reused-port binds become a possibility. */ if ((rg = tcp_rg_init(tcp)) == NULL) { return (ENOMEM); } tcp-\u0026gt;tcp_rg_bind = rg; } connp-\u0026gt;conn_reuseport = 1; 开启选项时检查是否已经加入现有组。是的话我们只更新一下组内簿记信息，否则我们在此时分配一个新组。\n} else if (connp-\u0026gt;conn_reuseport != 0 \u0026amp;\u0026amp; !do_enable) { /* enabled -\u0026gt; disabled */ ASSERT(tcp-\u0026gt;tcp_rg_bind != NULL); if (tcp-\u0026gt;tcp_state == TCPS_IDLE) { /* * If the connection has not been bound yet, discard * the reuse group state. Since disabling SO_REUSEPORT * on a bound socket will _not_ prevent others from * reusing the port, the presence of tcp_rg_bind is * used to determine reuse availability, not * conn_reuseport. * * This allows proper behavior for examples such as: * * setsockopt(fd1, ... SO_REUSEPORT, \u0026amp;on_val...); * bind(fd1, \u0026amp;myaddr, ...); * setsockopt(fd1, ... SO_REUSEPORT, \u0026amp;off_val...); * * setsockopt(fd2, ... SO_REUSEPORT, \u0026amp;on_val...); * bind(fd2, \u0026amp;myaddr, ...); // \u0026lt;- SHOULD SUCCEED * */ rg = tcp-\u0026gt;tcp_rg_bind; tcp-\u0026gt;tcp_rg_bind = NULL; VERIFY(tcp_rg_remove(rg, tcp)); tcp_rg_destroy(rg); 在未绑定的 socket 上关闭选项时，我们需要去配之前开启选项时分配的组结构。\n} else { /* * If a connection has been bound, it\u0026#39;s no longer safe * to manipulate tcp_rg_bind until connection clean-up * during tcp_free. Just mark the member status of the * connection as inactive. */ tcp_rg_setactive(tcp-\u0026gt;tcp_rg_bind, do_enable); } connp-\u0026gt;conn_reuseport = 0; } return (0); } 否则如前所述，我们不回收该组，而只更新簿记信息。\n这套逻辑可以在 UDP 上大致复刻。但我们还可以做的更深入一点：\n注意，之所以我们需要这么一大堆逻辑，是因为我们在开启选项时便分配了组的结构，而去配组结构的时候需要分析 socket 是否已经绑定。另外还有一点：在 socket 被绑定之前，这个分配的结构实际上根本没有被使用。\n既然如此，我们何不把组的分配延迟到 bind 之时呢？假设我们这么做，那么这里需要的逻辑会变成这样：\n 开启选项只标记一个开关，组分配延迟到 bind 时再处理 关闭选项时，如果 socket 尚未绑定，我们只需要关闭开关，不需要去配组，因为组并没有被分配 关闭选项时，如果 socket 已绑定，我们只需要关闭开关，不需要去配组，因为此时组不当被去配  综合一下，我们所要做的事情就只剩下标记开关了；逻辑瞬间被大幅简化。\n看上去不错，所以我们就这么干吧：\n我们把所有的复杂逻辑全部去掉，只留标记开关一项，在 UDP 中也同样。因为两边的操作完全一致，所以我们不必在两边协议栈中重复实现，而可以把共通实现直接提取到 conn_opt.c 中处理。开启选项相关的修改便就此大功告成。\n负载均衡：上 负载均衡这个行为，虽然说起来只有四个字，但仔细一想倒还挺吓人。我们要如何把数据包及连接负载均衡到同一地址的不同连接上，还要保证不重复，且不发到不同地址的连接上呢？\n要解决这个问题，首先我们需要回顾一下 illumos 的网络栈的架构：一个数据包从网卡驱动出来，一路送到用户程序，中间具体经历了哪些步骤？\n  数据包离开网卡驱动进入协议栈以后，第一个关卡是 ipclassifier。它负责将数据包分发到对应的连接上。具体而言，它会按照 IP 四元组（对于已经建立的连接而言）或者二元组（对于 SYN 一类的数据包而言）查询一个 Hash 表，找到对应的连接，然后将数据包压入该连接的 squeue 中等待处理。\n  这之后的一切协议处理都发生在连接自己的回路上；它会在经过协议栈层层处理之后一路上达用户程序。这整个过程（甚至包括 sockfs 这个抽象层）的处理全都由 squeue 保证独占，所以不会和其他连接产生任何干扰。\n  画出图形来表示的话，就是这样的一套结构：\ngraph TD; A[\"TCP 连接 1\"] --- B[\"IP Classifier\"] --- C[\"网卡驱动\"]; D[\"TCP 连接 2\"] --- B; E[\"TCP 连接 3\"] --- B; F[\"UDP 连接 1\"] --- B; G[\"UDP 连接 2\"] --- B; H[\"UDP 连接 3\"] --- B; I[\"其他协议连接\"] --- B;  这样捋一下以后，着手点就很清楚了：我们需要对 ipclassifier 动手脚。具体而言：我们需要修改 ipclassifier，让它知晓conn_rg_t的存在，并在分发数据包的时候不仅仅是找到（第一个）对应连接后直接发过去即可，而是需要在整个conn_rg_t里的所有连接之间负载均衡。\n ipclassifier.c  ipclassifier.c 是我的提交里改动最多的一个文件。目前的版本 (Patchset 10) 的改动多达375行。虽说其中大部分都是注释，不过也说明了本提交的关键所在正是这个组件。\n我们先不考虑如何构造conn_rg_t的问题；这不是 ipclassifier 该操心的事情。所以在我们写 ipclassifier 中的变动的时候，可以假设conn_rg_t已经被正确地填充了，我们只需要利用其中的信息即可。\n先理一下 ipclassifier.c 中的现有逻辑。整个文件中，有两个函数的名称引起了我们的注意：ipcl_classify_v4及ipcl_classify_v6。从名称上看，这两个函数分别是 IPv4 及 IPv6 数据包的分发函数；进一步阅读代码也能看出这点（我觉得读者应该有大致看懂这些代码的能力，所以不做具体分析了）：二者逻辑基本相似，而且大致操作都是按照协议栈和数据包地址查询对应 Hash 表，从而找到具体连接。显然这里便是我们的入手点。\n这里我们先对 UDP 进行改动，因为 UDP 是无状态协议，需要操心的事情最少。增加的逻辑很简单：\nif (connp-\u0026gt;conn_rg_bind != NULL) { /* * Have multiple bindings by SO_REUSEPORT, * do load balancing */ connp = conn_rg_lb_pick( connp-\u0026gt;conn_rg_bind, ipha-\u0026gt;ipha_src, ipha-\u0026gt;ipha_dst, ports); } 在直接把数据包丢给我们找到的第一个连接之前，我们先检查一下找到的conn_t是否加入了一个conn_rg_t组。如果是的话，我们不是直接返回找到的连接，而是按照数据包的地址信息在组内挑选一个连接返回。conn_rg_lb_pick实现了挑选连接的策略：求出数据包的 IP 地址信息的 Hash，然后按照 Hash 值选择一个连接。具体实现并不复杂（且就在文件下方），所以在此我们一笔带过。\nipcl_classify_v6中的改动类似，只是将 Hash 用的地址改成了 IPv6 地址。\nUDP 的改动就到此为止；接下来我们考虑一下 TCP 的问题。对于 TCP 而言，除了上述的改动之外，我们有没有什么其他需要做的呢？\n首先，TCP 是有连接的概念的。这也就是说，一个conn_t对应的 TCP 连接不一定是我们bind上来接受accept()的连接，还有可能是accept以后创建的单独连接；后者显然不应当参与负载均衡。\n其次，accept()在创建 TCP 连接之时需要先完成 TCP 握手，该握手是有状态的，因此所有的数据包都应该发到同一个连接上。我们的负载均衡并不考虑数据包的内容。这会搞乱握手造成问题吗？\n再回顾一下 TCP 握手的处理：\nillumos 对 TCP 握手的处理方式是这样的：我们在监听 socket 的回路上接受 SYN 数据包，在 SYN 之后立即创建出新的连接（称为 eager）。之后的握手全部在 eager 的回路中完成，监听 socket 不再参与。\n换句话说，实际上监听 socket 需要接受的只有一个 SYN 包而已。如果我们能保证创建出来的连接不参与负载均衡的话，我们自然也就不会搞乱握手的问题。那么保证这点又需要什么呢？\n什么也不用做。因为我们预定要将conn_rg_t的创建和填充放到bind()相关的代码中去做，而创建出来的新连接不走bind()，自然也不会加入conn_rg_t；而不加入conn_rg_t的 socket 相关的代码我们完全没动，所以他们并不会参与负载均衡。\n结论：TCP 没有额外的工作要做，采取和 UDP 完全一致的变动即可。似乎还是比我们预想中的轻松不少？\n负载均衡：下 完成了利用conn_rg_t的代码，接下来我们需要的便是正确维护conn_rg_t，好让我们刚刚写出来的代码可以利用它。如前所述，我们会将维护conn_rg_t的操作放到bind()相关的代码中处理，所以首先我们还是来看看bind()的时候到底做了些什么。\n tcp_bind.c  这里面的函数挺多，调用链也有些复杂（涉及到 TLI 和 sockfs 的交互问题），不过最终都规约到一个函数上：tcp_bindi()。该函数里面的操作大致是检查现有 Hash 表，如果找到地址冲突的话，视选项情况决定是直接返回错误，还是插入新项覆盖旧监听 socket。很方便的一点是，因为SO_REUSEADDR选项的存在，我们需要的大部分逻辑都已经被实现了；剩下的只是对conn_rg_t的维护了。重点改动如下：\nif (attempt_reuse) { /* Attempt to join the existing group */ int err; conn_rg_t *rg; ASSERT(ltcp != NULL); ASSERT(ltcp-\u0026gt;tcp_connp != NULL); ASSERT(ltcp-\u0026gt;tcp_connp-\u0026gt;conn_rg_bind != NULL); ASSERT(connp != NULL); ASSERT(connp-\u0026gt;conn_rg_bind == NULL); err = conn_rg_insert( lconnp-\u0026gt;conn_rg_bind, connp); if (err != 0) { mutex_exit(\u0026amp;tbf-\u0026gt;tf_lock); *errcode = err; return (0); } connp-\u0026gt;conn_rg_bind = lconnp-\u0026gt;conn_rg_bind; } 这段代码大致继承自 joyent 的原提交。如果目前有冲突的 socket，且该 socket 加入了一个conn_rg_t组，则说明它在绑定时开启了SO_REUSEPORT；因此我们试图加入现有组。conn_rg_insert中还有一些其他的权限检查，不过逻辑并不复杂，在这里同样一笔带过。\na/* * If we are the first here and have SO_REUSEPORT set, * set up connp-\u0026gt;conn_rg_bind */ if (connp-\u0026gt;conn_reuseport \u0026amp;\u0026amp; (connp-\u0026gt;conn_rg_bind == NULL)) { conn_rg_t *rg = conn_rg_init(connp); if (rg == NULL) { mutex_exit(\u0026amp;tbf-\u0026gt;tf_lock); *errcode = ENOMEM; return (0); } connp-\u0026gt;conn_rg_bind = rg; } 在没有冲突 socket 的情况下，我们需要额外检查调用bind()的 socket 是否开启了SO_REUSEPORT。若已开启，则创建新的conn_rg_t以供后来者加入。\nUDP 的逻辑也大致如此，在此不再赘述。\n杂项 上述内核中的改动实现了功能的核心。但作为一个提交给整个项目的 patch，仅仅写出这些代码还是不够的；我们还需要加点佐料，例如测试。\nillumos-gate 中已有一套成熟的测试框架；这套框架和利用它的测试位于 usr/src/test 下。仔细检查相关内容以后，我决定把我的测试加载 os-tests 目录下。\n另外我还试图做了点 man page 的维护。虽说最终结果似乎不尽人意（显然我的英语写作水平还远没到 native speaker 的程度），不过社区里某位维护者亲切地提出他可以帮我完成文档问题，所以我也便恭敬不如从命了。\n结语 于补丁完成以后再分析，似乎这个补丁的内容三言两语便能写完，但实际完成这个补丁却花了我好几个月时间；捋清思路以及反复验证实现所需要的功夫远比纸面看上去的要多得多。不过正是这样的过程才让我获益匪浅：如何参与现有项目，如何与其他人合作，如何保证成品的质量，这些东西绝非写几个玩具项目就能学到的。\n另外在这个过程中 illumos 内核代码的高质量也给我带来了极大的帮助。这点让我更加深刻地体会到了代码结构清晰，以及文档详尽的重要性：这些品质在单次开发的时候未必有很明显的优点，但却能造福后人。不信的话，对比一下我的 patch 和原 Linux 的 patch，你立刻就能体会到这点（没错，我又在黑 Linux 了）。\n最后我再打一次广告：身为 Solaris 的后继者，一个已经在高端生产环境历经数十年检验的项目，illumos 的质量毋庸置疑；而精密规划过的结构以及详尽的注释让它的代码上手难度比 Linux 低了不知道多少个数量级。对于任何有志成为内核 hacker 的人来说，我觉得 illumos 都是个不错的起点，所以强烈推荐诸位在选择项目的时候认真考虑一下 illumos。相信它不会让你失望。\n  https://github.com/joyent/illumos-joyent/commit/310084386497b66d8f5b66f4887dfe1a57e1cb94 \u0026#x21a9;\u0026#xfe0e;\n https://github.com/joyent/illumos-joyent/commit/4a663ad4eabd38f9c6397c5205cc12f083b474ca \u0026#x21a9;\u0026#xfe0e;\n   ",
    "ref": "/blog/illumos/notes-on-reuseport-support/"
  },{
    "title": "本站信息",
    "date": "",
    "description": "",
    "body": "别看我，看文。\n许可证 若无另行声明，则本站原创文章默认以 CC-BY-NC-SA 4.0 许可证发布。\n原创代码一律以 MIT Expat 许可证发布。\n注意站内一切内容均为基于我主观认知的产物；我会尽力确保内容的准确性，但不对此给出任何保证。对本站内容照本宣科而产生的后果本人概不负责。\n联络方式  邮箱：araragihokuto@outlook.com Matrix: @cyberwanderer:privacytools.io IRC: Mokou@freenode.net \u0026ndash; 请于 #c_lang_cn 找我 Pleroma: miko@pl.tsukuyomi.dev \u0026ndash; 可与 Mastodon 互通。  我拒绝使用 Telegram。原因见此。\n我不打算鼓励 QQ 和微信的使用，所以不在此处列出二者的帐号。\n",
    "ref": "/about/"
  },{
    "title": "初等屠龙技：阿库娅也能看懂的 OS 编写入门 序",
    "date": "",
    "description": "",
    "body": "其之一 引 如是我闻：程序员有三大浪漫，曰OS，曰CG，曰编译器。虽说引用*乎上业界爱抖露的言论是个高风险行为，不过我还是打算拿这句话作为开篇之语——反正这是我自己的博客，管他那么多。\n我还记得小学三年级时的自己。那时候我还是个对计算机充满好奇的熊孩子，脑袋里充斥着一行代码没读过的外行人对编程的幻想。当时我听说 Linux 和 Windows 都是用 C 写的，于是误以为花个一两年的时间把 C 入了门，就足以写出一个操作系统来自娱自乐——我到现在还能记得当时我幻想中的那个自制 OS 的 BIOS 式蓝色背景文本 GUI（现在回首，在 UI 的设想上我还真是意外地有自知之明，没幻想一个华丽的3D 桌面出来）。\n当然不必说，买回来一本 VB 教程和一本国内大学 C++ 教材的我自然是连门都没碰到，甚至连编程本身也没学到几分。真正要入门 OS 开发，那还得等到初二的时候有人给我指了路，我才跟着一个相对实用的教程写了半个内核出来。\n关于我自己的闲话就到此为止。至于提笔编写这个教程的动机——如前文所述——是浪漫。虽说既然是如此普遍的浪漫，教程自然不会少，但我总觉得编写玩具 OS 可以采取一个不那么实用向的角度（不会真的有人觉得自己花一个月就能打败 Windows\u0026amp;Linux\u0026amp;macOS 吧？）。然而不幸，我所能找到的 OS Tutorial 几乎都始于从 0x7c00 启动开始读扇区，或者从 multiboot 启动之后开始往 0xb8000 写字符显示 VGA 文本。\n这无可非议。毕竟写 OS 总得让人有点成就感，而在自己的 x86 机器上跑一个能往屏幕上吐出东西的裸机程序大概是获得成就感的最快方式了。但我还是觉得不高兴：既然都已经放弃实用性追求浪漫了，身为活在新世纪的第二个十年的年轻人，我们何不抛开这些历史的苟且，搞些更优雅更浪漫的东西出来呢？\n正因如此，我打算在本系列中采取一个不那么寻常的路子。我们将首先实现一个 RISC-V 上的类 Unix 操作系统，一直到能跑起一个基础的 shell 为止，但我们并不止于此；之后，我们还要把我们这个玩具 OS 移植到 x86-64 上。\n这种路径会带来几个好处：\n 因为我们已经预定了多体系支持，这便要求我们在编写内核的时候留个心眼，而不会满足于平台相关的七拼八凑。 不同体系之间的对比能更加明显地凸显出哪些部分是操作系统的本质，哪些部分是与体系交互的抽象层。我个人希望这种概念上的明晰能让入门读者受益更多。 众所周知，x86 的臃肿和混乱可谓臭名昭彰。从 RISC-V 上开始能让我们更快地真正开始编写我们的操作系统，而不用花大力气对付实模式/保护模式/长模式，以及其他那堆历史遗留的东西。  当然，考虑到大部分读者还在用着 x86 的机器，所以如果有读者觉得这种路径太繁琐/太慢热的话，本系列恐怕不适合你。无妨——优秀的 OS Tutorial 到处都是，相信读者稍微检索一下即可找到。\n而如果你是那部分还没被劝退的读者的话——欢迎登机，祝旅途愉快。\n背景知识 鉴于本系列是 OS 编写入门教程，而不是编程入门教程，我会假定读者具有以下背景知识：\n 以 C 语言编写程序的能力。本教程中绝大部分内容会用 C 语言实现，故而假定读者具有理解示例，以及自行补足或修改示例的能力。（另，别跟我推销 Rust，也别问我为什么不接受推销。） 对计算机系统组成的基本概念。OS 不止是 HAL，但 OS 通常需要实现一个 HAL。在使用硬件之前显然需要对硬件有概念。 OS 相关的基本理论。当然本系列并不要求读者成为 OS 专家，但没有理论的引导我们只会晕头转向，所以基础的理论知识也是必要的。  以上列表我会随时补充。感到自己知识有所欠缺的读者，可以预先补足，或者随着我们的进度推进一道补足。\n参考资料 教程本身是有极限的，额外的参考资料必不可少。以下将会列出我本人认为有价值的材料，方便读者随时查阅：\n OSDev Wiki OS 开发相关的 wiki，上面零散地分布着大量实用而有价值的资料。十星推荐。 RISC-V 标准 RISC-V 体系的标准。在我们编写 RISC-V 上的程序的时候将会大量参考这些内容。 《AMD64 Architecture Programmer\u0026rsquo;s Manual》AMD 官方提供的 AMD64 参考手册。在我们进行 x86-64 移植的时候将会大量参考该手册。  以上列表我会随时补充。\n 闲话少叙，是时候开始干点实事了。下一话，你好，THE WORLD!\n",
    "ref": "/blog/operating-system/primitive-osdev-intro/intro/"
  },{
    "title": "密码学，从入门到劝退：古典密码（上篇）",
    "date": "",
    "description": "",
    "body": "其之二 推古及今：古典密码与现代密码 与其他很多学科不同的是，始于70年代的现代密码学，并非是在古典密码学上平缓发展而来的学科，而是一次开天辟地式的飞跃。之所以说是“开天辟地式”，是因为我们直到那时候才开始真正体系化地运用数学手段对密码学建模。密码学的这个飞跃大概可以说是到来得惊人地晚。\n而若以现代密码学的眼光回首望去，在这之前的古典密码学时代（哪怕是不到一百年前的20世纪初期），相比之下可谓是茹毛饮血——那时候的攻防手段基本还是基于语言文本的分析，而非如现代密码学一般基于信息论、离散概率以及其他数学手段。因为没有衡量安全性的手段，古典密码学里自然也无从对加密算法进行数学层面上的安全分析，加解密攻防不可避免地变成了猫鼠游戏式的勾心斗角。\n但即便如此，认真回顾这个持续了数千年的古典时代也是极有价值的。以史为鉴，将能让我们更为清晰地认知到加密算法所面对的威胁，以及现代密码学所提供的数学手段的宝贵。\n因此，虽说有老生常谈之嫌，本文仍将迅速地带领读者过一遍几种典型的古典密码。\n其之二甲 以史为鉴：古典密码（上篇） 一点背景知识：术语科普 名不正则言不顺。在正式进行古典密码的科普之前，我们需要先储备点基础的密码学术语。\n 密码（Cipher）：进行加密或解密的算法。注意此语境下的密码为 Cipher 的翻译，而非通常汉语口语中由用户输入的 Password。 密钥（Key）：一串保密信息，用于指导密码（Cipher）对原文及密文进行变换。 明文（Plaintext）：未经加密的原始消息。 密文（Ciphertext）：明文经加密算法变换后的产物。 COA，惟密文攻击（Ciphertext only Attack）：最严格的攻击模型。假定攻击者只能获得加密后的密文。此时攻击者的目标通常是获得明文，以及密钥；但在特定情况下，即使攻击者无法获得完整的明文，只要能得到关于明文的更多信息，也可算作成功。 KPA，已知明文攻击（Known Plaintext Attack）：假定攻击者能够获得明文和与之对应的密文的攻击模型。此时攻击者的目标通常是获得密钥。 CPA，选中明文攻击（Chosen Plaintext Attack）：假定攻击者能够自选任意明文，并获得对应密文的攻击模型。此时攻击者的目标通常是获得密钥。 CCA，选中密文攻击（Chosen Ciphertext Attack）：假定攻击者能够自选任意明文，并获得对应解密后的明文的攻击模型。此时攻击者的目标通常是获得密钥。  注意以上名词并非局限于古典密码学——不如说这些名词在现代密码学里会被更广泛地应用。\n在明确词义之后，我们终于可以开始讨论古典密码了。而最适合打头阵的，当然是替换密码。\n替换密码 谈到“密码”二字，绝大部分人的第一反应恐怕都是替换密码。这东西原理很简单：设定一张替换表，其中每一个字母都会被一一映射到另一个字母上；加密时将明文中每一个字符按照映射替换成对应的字母，解密则只是简单地逆向映射。\n顺嘴一提，我们可以将这个映射表看作密钥，只要能得到它，攻击便宣告成功。\n这东西安全度如何呢？按照我们上面提到的四种攻击模型分别讨论一下：\nCPA 以及 CCA：显然，无论我们手里的神谕机（Oracle）是加密神谕还是解密神谕，我们都只需要把所有字母灌进去，立刻就可以得到完整的映射表，不费吹灰之力。\nKPA：取决于能够获得的明文长度，以及明文中不同字母的种类，我们至少能获得映射表的一部分。对于那些字母表不大的语言来说，恐怕不需要多长的明文就足够我们推出整张映射表。\nCOA：这里需要我们稍微动点脑筋。假设明文的语言已知的话，我们可以采用一点统计手段：大部分自然语言的字母出现概率并不随机。以英语为例，e 出现的概率会是最高的，所以只需要统计出密文中出现概率最高的字母，我们便可以大概率确定它与 e 互相对应。其他字母也可以根据明文的语言特征分析出来。具体的例子因为过于经典已经在各种密码学教程中烂大街了，在这里我不再赘述。\n显然，替换密码的安全度并不高。\n凯撒密码及其变体 严格来说，凯撒密码其实是更弱一些的替换密码，所以对于替换密码的攻击只会对凯撒密码更有效。不过鉴于凯撒密码实际上我们之后将要介绍的不少其他密码的基础构造之一，这里我还是把它单独拎出来讲一下。\n凯撒密码的构造更为简单：将明文的每个字符按字母表顺序后移三位，即可得到密文。但仅仅如此的话，凯撒密码本身并不足以成为我们所讨论的密码（Cipher）：它没有密钥。这也是为什么本节的标题强调了“及其变体”：我们可以将这个构造略微扩展，令原本的后移三位变为后移 k 位，此时这里的 k 便可被视作密钥。\n显然，要破解凯撒密码，我们只需要推出 k；而要推出 k，只需要推断出明文中任意一个字母于密文中所对应的字母，二者的距离即为 k。鉴于其本质仍是替换密码，运用针对替换密码的攻击手段推出密钥轻而易举。\n能否对这个构造略微修改，使得它变得更加安全呢？\n维吉尼亚密码 一点花边：维吉尼亚密码的名称来源于 Blaise de Vigenère(1523-1596)，但现今已知的对该密码的最早论述实际由 Giovan Battista Bellaso 于1553给出。\n以英语为例，我先简单介绍一下维吉尼亚密码：\n维吉尼亚密码的密钥是一个单词（或者说，一串固定长度的文本）。这里我们先选用一个充满酸味的密钥，\u0026ldquo;LEMON\u0026rdquo;。\n给出一段任意长度的文本，我们先将明文字母和密钥对齐地写在上下两行。若密钥长度不足，则循环密钥补齐。例如，若我们需要加密 \u0026ldquo;ATTACKATDAWN\u0026rdquo;:\n然后，我们将明文中的每一个字母循环后移“密钥中对应字母的序数”位，（换言之，若密钥中对应字母是A，则后移0位；若密钥中对应字母是 B，则后移1位，依此类推）：\n以 C 语言实现的话：\n/* Assume ASCII */ char encrypt_char(char c_plaintext, char c_key) { return (c_plaintext - \u0026#39;A\u0026#39; + (c_key - \u0026#39;A\u0026#39;)) % 26 + \u0026#39;A\u0026#39;; } /* Assume `out` has enough capacity to hold ciphertext */ void encrypt(char *out, const char *plaintext, const char *key) { size_t key_size = strlen(key), plaintext_size = strlen(plaintext); for (size_t i = 0; i \u0026lt; plaintext_size; ++i) { out[i] = encrypt_char(plaintext[i], key[i % key_size]); } out[plaintext_size] = \u0026#39;\\0\u0026#39;; } 花点时间理解下这东西。好了吗？你能想出破解方法吗？\n想不出来也没关系，毕竟这东西发明出来以后花了三百年才被破解。不过如果你还不想太早放弃的话，我可以给点提示：我们可以先假定密钥长度已知。\n下有答案，不想被糊一脸的话别急着下滑。\n 维吉尼亚密码的破解 假定密钥长度已知（例如，在刚才的例子里密钥长度是5），我们可以先把密文按照密钥长度分组。比如上例中，我们可以每五个字符分一组：\n然后我们将密文竖着看。注意到什么了吗？\n没错，每个竖行都是用同一个字母加密的，故而位移相同。也就是说，每一个竖行都是一串经过凯撒加密的密文。此时破解方法已经呼之欲出了：我们可以对每个竖行分别应用一次针对凯撒加密的攻击，然后即可反推出密钥。\n如果密钥长度未知呢？那也不难，我们只需要先假定密钥长度为1，进行攻击尝试；若无法得到有意义的明文，则再假定密钥长度为2，进行攻击尝试，依次穷举下去，直到我们得到有意义的密文。在仅有纸笔的时代密钥长度通常并不长，所以这个过程其实没有想象得那么耗时。\n惊人地简单，是不是？\n 到这里我们可以先休息一下，因为接下来我们要介绍的东西值得单独分出一篇博文：转子加密机。这一类加密机中最著名的恐怕便是二战时纳粹德国使用的 Enigma 密码机了。尽管与之相关的神话数不胜数，但我将要演示的，其实是 Enigma 以如今的眼光来看，安全性到底低到什么程度。\n下一话，Enigma 之死！\n",
    "ref": "/blog/cryptography/cryptography-introduction/classic-cryptography-1/"
  },{
    "title": "密码学，从入门到劝退：引论",
    "date": "",
    "description": "",
    "body": "密码学——当下被广泛应用，却又被广泛忽视的学科。在这个 HTTPS / SSH / WPA / 某种工具（咳咳，你懂） 满天飞的时代，说你每分钟都在应用密码学大概不是什么夸张。但另一方面，有很大一部分人，包括那些在生产环境中应用密码学组建构建系统的人，可以说连密码学的常识都没有。\n惭愧地说，我其实也是其中一员。在 ProtonMail 勾起我对密码学的兴趣之前，我甚至干出过拿$$ SHA256(Password | Salt) $$当密码 Hash 存在数据库里的蠢事（别动歪心思，这东西现在已经不在线上运行了）；而且我毫不怀疑部分读者可能还没看出来这有什么问题。\n不要紧。这个系列的目标正是普及密码学常识——至少是在我力所能及范围内的常识。\n动机，以及本系列的目标 我记得之前看到过一个花边新闻（不幸，现在我找不到来源了）：\n一位密码学家好奇 WebAssembly 在密码学意义上的安全性，于是在推上向 WA 的某个核心开发者询问 WebAssembly 的时间恒定性相关考量。他得到的回应是一个振聋发聩的问句：“旁道是什么？”\n我无意指责这位不知道旁道的开发者。但这确实折射出一个严重的问题：我们的从业者对密码学常识的缺乏实际相当严重。这正是启发我创作本系列的原因。\n读者要注意的是，作为“密码学劝退”科普而非“密码学”科普，我并不打算在本系列里深入讲解密码学的知识，特别是密码学的数学内容。入门密码学并非本系列的目标；恰恰相反，本系列的目标是培养读者对于密码学的敬畏之心，同时让读者无需成为密码学家也能较安全地应用现有的密码学组件。\n更明确地说，在读完本系列以后，读者应当具备如下知识：\n 知道古典密码学和现代密码学的差异，以及现代密码学的安全保证。 对常见的密码学算法及实现有所了解，明确它们的能力和限制。 明白为什么密码学领域尤其不鼓励自造轮子。  选择这样的角度，一方面是因为本人的密码学水平远未达到可以进行教学的程度，另一方面则是因为密码学界并不缺乏专业的教材。故而任何有志于密码学研究的读者，应当做好接下来需要自行寻找其他教材提升的准备。\n关于“劝退”二字  Anyone, from the most clueless amateur to the best cryptographer, can create an algorithm that he himself can\u0026rsquo;t break. It\u0026rsquo;s not even hard. What is hard is creating an algorithm that no one else can break, even after years of analysis. \u0026ndash; Bruce Schneier, 1998 如上所言，本系列的目标之一是令读者知晓“为何密码学领域尤其不鼓励自造轮子”。实际上这是本系列的重中之重。\n无论直接还是间接，我自己见过的试图自造轮子的人简直黄河沙数。而其中大部分人不是已经悲剧，就是正在通往悲剧的路上。常见的表现有以下几种（顺序无关）：\n 搞了一套自造算法，试了一下发现自己破解不了，于是便认为安全。 搞了一套自造算法，觉得只要不把算法细节公布出来，自己就是安全的。 拿一些老旧的算法(RC4/DES/SHA1 等等)互相套娃，然后觉得自己的设计比这些组件更安全。 用 C/Java/JS/其他什么高级语言写了一套密码学算法实现，写了几个单元测试，发现输入输出没什么问题，然后就认定实现正确。  上表远非穷尽，而我也不知道列出来的这几个常见错误已经让多少人中枪；不过如果你未经密码学训练，而又曾经自信满满地实现过一套安全系统，那么你该当心了：本系列正是用来击碎你的自信的。当你知道现实中的攻击未必只是盯着一段密文反推原文，当你知道数学上绝对安全的算法一旦变成实现就多出了成千上万个漏洞以后，懵懂时期的安全感还能保持住几分呢？至少当我回头看我之前用上密码学的程序的话，我觉得那些全是我的黑历史。\n引论到此为止。这篇文章中提到的内容，我都会在之后尽可能地展开讲述。所以若以上内容能够激起你的兴趣的话，Stay tuned。\n 下一话，古典密码，堂堂连载！\n",
    "ref": "/blog/cryptography/cryptography-introduction/intro/"
  },{
    "title": "「译」Telegram，又曰“退下，让老子的数学PhD来！”",
    "date": "",
    "description": "",
    "body": " 译注 原文见《Telegram, Aka \u0026ldquo;Stand back, we have Math PhDs!\u0026quot;》。该文发表于2013年，不少内容或许已经过期，故仅供参考。\n   免责声明 本文如今已十分古老，未必能反应 Telegram 协议于时下的情况。这期间已经有了不少其他研究进展，故而此文不应当被用作你选择加密聊天软件的依据。虽说如此，就我个人而言，我依然认为 Telegram 的加密系统很古怪，并且他们对此的洗地言论站不住脚。如果你想要我推荐一个加密聊天软件：找一套基于 Axolotl/Signal 协议的体系。这套协议设计良好，且已经过大量审查。 Signal 和 WhatsApp，以及一些其他的程序都使用了这套协议。\n 本文是本系列中第二篇介绍奇怪加密 App 的，对象是最近甚嚣尘上的 Telegram。\n据他们网站所言，Telegram “基于云计算而且大量运用加密”。它有多安全？\n 非常安全。我们的技术基于一套新协议，名为MTProto，由我们自己的专家研发，并运用了经过时间考验的加密算法。目前而言，你在 Telegram 上的消息泄漏的最大风险是你妈从你背后看你屏幕。其他的风险我们都能搞定。\n (引自他们的 FAQ)\n嗯，非常安全，他们自己这么说的。\n行，那我们就来看看到底多安全。\n目前可以公开的安全情报 他们的网站上发布了协议的细节。他们其实可以多画些示意图，而不是写一堆纯文字，不过现在这样也算能读。还有个拿 Java 写的开源协议实现。这算个优点。\n关于他们的团队（嗯，我还记得我说过不搞诉诸人身，但毕竟他们一直在吹这点）：\n Telegram 背后的团队，由 Nikolai Durov 牵头，共计六个 ACM 冠军组成，其中半数都是数学PhD。他们花了两年时间来设计当前的 MTProto。虽说学历未必代表能力，但至少能说明这套协议是海量专家精确计算的结果（原文：result of thougtful and prolonged work of professionals）\n （来自 Hacker News）\n他们不是密码学家，但他们有数学学术背景。好耶！\n那么，整个体系架构长什么样？基本上就是世界各地放几台服务器，在客户端之间转发信息。 身份验证只做在客户端和服务端之间，而不是客户端之间点对点验证。客户端和服务端之间有加密，但用的不是TLS（而是一些自制的协议）。加密可以端对端进行，但因为没有身份验证，所以服务器可以进行中间人攻击。\n本质而言，他们的威胁模型就只是“信任服务器”。在公网上传输的内容可能被安全加密了，但我们毕竟无从了解他们的服务器间通信细节，也无法得知他们的数据存储方案。以今天的眼光看来，这套东西既没意思，又昭示着不安全和粗心。类似的系统可以参考 Lavabit 或者 iMessage。这套系统并不能阻止执法部门的监听或者服务器渗透。更糟糕的：你都没法检测到和你聊天对象之间的中间人攻击。\n我可以就此收手，但这样就没意思了。真正的乐子其实常在他们的加密设计里。这些设计粗看起来似乎合理，但对加密算法的选择既奇怪又不安全，而且每一个设计都无谓地选择了最复杂的那种。\n网络协议 网络协议有两个阶段：密钥交换和通信。\n密钥交换过程会向服务器注册一个设备。为此他们自己搞了一套协议，理由是 TLS 太慢而且太复杂。有一说一，确实：TLS 需要在客户端和服务器间跑两个来回 (round trip) 才能完成密钥交换。而且还需求一个 x509 证书，以及一套 RSA 或者 DSA 这种公钥加密算法，最终还需要走一趟 Diffle-Hellman 密钥交换算法。\nTelegram 大幅简化了这个过程（迫真），只需要三个 RT，用上 RSA、 AES-IGE（某个没其他人用的奇怪加密模式），以及 DH 密钥交换，同时还有一套工作量证明（客户端得因数分解个数字，估计是个 DoS 防护措施）。另外，他们还用了一套土制算法来从服务器和客户端生成的 nonce 导出 AES 密钥和 IV（ server_nonce 在通信过程中是明文传输的）：\nkey = SHA1(new_nonce + server_nonce) + substr(SHA1(server_nonce + new_nonce), 0, 12); iv = substr(SHA1(server_nonce + new_nonce), 12, 8)+ SHA1(new_nonce + new_nonce) + substr (new_nonce, 0, 4); 注意 AES-IGE 是不带认证的。所以他们自行实现了完整性验证，方法是简单地对原文取个 SHA1 （没错，甚至都没用个正经的 MAC），然后把 Hash 结果和原文一起加密（没错，这就是个迫真 MAC-then-Encrypt）。\n最终的 DH 交换会创建一个储存在服务端和客户端（搞不好还是明文存储）的认证密钥。\n我实在难以理解他们为什么要搞一套这么复杂的协议。他们本来可以这么搞：客户端生成一对密钥，用服务端的公钥加密客户端的公钥，和 nonce 一起发给服务端，然后服务端把用客户端公钥加密过的 nonce 发回来。简单有效。而且这样还可以向客户端提供公钥，实现端对端加密。\n至于通信阶段：他们用了一套服务端加盐、消息 ID 和消息计数器的组合来阻止重放攻击。有趣的是，他们的消息密钥是用 SHA1 值的低128位组成的。这个消息密钥用明文传输，所以如果你监听到了消息头，那么此处应有巨大多信息泄漏。\n用来加密消息的 AES 密钥（还是 IGE 模式下的 AES）是这么生成的：\n如下是从 auth_key 和 msg_key 计算 aes_key 和 aes_iv 的算法：\nsha1_a = SHA1(msg_key + substr(auth_key, x, 32)); sha1_b = SHA1(substr(auth_key, 32+x, 16) + msg_key + substr(auth_key, 48+x, 16)); sha1_с = SHA1(substr(auth_key, 64+x, 32) + msg_key); sha1_d = SHA1(msg_key + substr(auth_key, 96+x, 32)); aes_key = substr(sha1_a, 0, 8) + substr(sha1_b, 8, 12) + substr(sha1_c, 4, 12); aes_iv = substr(sha1_a, 8, 12) + substr(sha1_b, 0, 8) + substr(sha1_c, 16, 4) + substr (sha1_d, 0, 8); 其中，在客户端给服务端的消息中 \\(x = 0\\)，而服务端给客户端的消息中\\(x = 8\\)。\n因为 auth_key 是永久的，而消息密钥只依赖于服务端提供的盐（24小时一换）、会话 ID（估计是永久的，不过可能会被服务端忘掉）以及消息的开始部分，可能很多消息都会生成同样的消息密钥。没错，很多消息会共享同样的 AES 密钥和 IV。编辑：据 Telegram 的评论所言，每条消息的 AES 密钥和 IV 都是不同的。但还是那句话，根据消息内容来生成密钥和 IV 是个及其糟糕的设计。这二者必须从 CSPRNG 生成，和加密内容保持无关。\n编辑2：新的协议示意图澄清了密钥是由一个很弱的密钥导出算法推出来的，而且部分内容直接明文传输。这里大概有不少可以拿统计分析搞事情的地方。\n编辑3：行吧，如果你把同一条消息发两遍（在一天当中，因为服务端生成的盐能活24小时），密钥和 IV 会是一样的，而且密文也会是一样的。这是个正儿八经的安全漏洞。通常的解决方式是常换 IV （即使是 WEP 这样的破烂协议都知道这么干）而且常换密钥（也即 TLS 或者 OTR 里的前向安全性）。消息原文里包含一个（时间相关）的消息 ID 以及自增的消息序列号，所以客户端不会接受重放的消息，或者太旧的消息。\n编辑4：有人在端对端聊天中找到了一个漏洞。从 DH 算法生成出来的密钥会和服务端提供的 nonce 结合：key = (pow(g_a, b) mod dh_prime) xor nonce。这样，服务端就可以通过在两个客户端间生成同样的密钥，以此进行中间人攻击，让密钥验证失效。Telegram 已经更新了协议描述，打算修复这个漏洞。（这个 nonce 的引入是为了修复某些移动设备上的 RNG 问题）。\n 译注 我觉得这个洗地站不住脚。RNG 缺陷可以有多种方式解决：比如 EdDSA 演示实现中将128个随机字节 Hash 到 32个，以此避免暴露 RNG 原始输出防止逆推 RNG 状态。TG 这个解决方法在我看来非蠢即坏——在加密相关问题上我倾向于假定后者。\n 正经说，我从来没见过有人用 MAC 来生成加密用密钥的。就算你想埋后门，也不用埋得这么明显啊……\n结论：快跑。里面没有什么全新发明，而且他们还通过自行组合 RSA、AES-IGE、纯 SHA1 完整性验证、MAC后加密、和自制 KDF 引入了一堆自制安全漏洞。比起 Telegram，你更应该用个有名的而且被审计过的协议，比如说 OTR （可用于 IRC 及 Jabber ），或者 TextSecure 的 Axolotl key ratcheting。\n",
    "ref": "/blog/cryptography/telegram-aka-stand-back-we-have-math-phds/"
  }]
