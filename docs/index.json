[{
    "title": "本站信息",
    "date": "",
    "description": "",
    "body": "别看我，看文。\n许可证 若无另行声明，则本站原创文章默认以 CC-BY-NC-SA 4.0 许可证发布。\n原创代码一律以 MIT Expat 许可证发布。\n注意站内一切内容均为基于我主观认知的产物；我会尽力确保内容的准确性，但不对此给出任何保证。对本站内容照本宣科而产生的后果本人概不负责。\n联络方式  邮箱：araragihokuto@outlook.com Matrix: @cyberwanderer:privacytools.io IRC: Mokou@freenode.net \u0026ndash; 请于 #c_lang_cn 找我  我拒绝使用 Telegram。原因见此。\n我不打算鼓励 QQ 和微信的使用，所以不在此处列出二者的帐号。\n",
    "ref": "/about/"
  },{
    "title": "初等屠龙技：阿库娅也能看懂的 OS 编写入门 序",
    "date": "",
    "description": "",
    "body": "其之一 引 如是我闻，程序员有三大浪漫：OS、CG、编译器。虽说引用*乎上业界爱抖露的言论是个高风险行为，不过我还是打算拿这句话作为开篇之语——反正这是我自己的博客，管他那么多。\n我还记得小学三年级时的自己。那时候我还是个对计算机充满好奇的熊孩子，脑袋里充斥着一行代码没读过的外行人对编程的幻想。当时我听说 Linux 和 Windows 都是用 C 写的，于是误以为花个一两年的时间把 C 入了门，就足以写出一个操作系统来自娱自乐——我到现在还能记得当时我幻想中的那个自制 OS 的 BIOS 式蓝色背景文本 GUI（现在回首，在 UI 的设想上我还真是意外地有自知之明，没幻想一个华丽的3D 桌面出来）。\n当然不必说，买回来一本 VB 教程和一本国内大学 C++ 教材的我自然是连门都没碰到，甚至连编程本身也没学到几分。真正要入门 OS 开发，那还得等到初二的时候有人给我指了路，我才跟着一个相对实用的教程写了半个内核出来。\n关于我自己的闲话就到此为止。至于提笔编写这个教程的动机——如前文所述——是浪漫。虽说既然是如此普遍的浪漫，教程自然不会少，但我总觉得编写玩具 OS 可以采取一个不那么实用向的角度（不会真的有人觉得自己花一个月就能打败 Windows\u0026amp;Linux\u0026amp;macOS 吧？）。然而不幸，我所能找到的 OS Tutorial 几乎都始于从 0x7c00 启动开始读扇区，或者从 multiboot 启动之后开始往 0xb8000 写字符显示 VGA 文本。\n这无可非议。毕竟写 OS 总得让人有点成就感，而在自己的 x86 机器上跑一个能往屏幕上吐出东西的裸机程序大概是获得成就感的最快方式了。但我还是觉得不高兴：既然都已经放弃实用性追求浪漫了，身为活在新世纪的第二个十年的年轻人，我们何不抛开这些历史的苟且，搞些更优雅更浪漫的东西出来呢？\n正因如此，我打算在本系列中采取一个不那么寻常的路子。我们将首先实现一个 RISC-V 上的类 Unix 操作系统，一直到能跑起一个基础的 shell 为止，但我们并不止于此；之后，我们还要把我们这个玩具 OS 移植到 x86-64 上。\n这种路径会带来几个好处：\n 因为我们已经预定了多体系支持，这便要求我们在编写内核的时候留个心眼，而不会满足于平台相关的七拼八凑。 不同体系之间的对比能更加明显地凸显出哪些部分是操作系统的本质，哪些部分是与体系交互的抽象层。我个人希望这种概念上的明晰能让入门读者受益更多。 众所周知，x86 的臃肿和混乱可谓臭名昭彰。从 RISC-V 上开始能让我们更快地真正开始编写我们的操作系统，而不用花大力气对付实模式/保护模式/长模式，以及其他那堆历史遗留的东西。  当然，考虑到大部分读者还在用着 x86 的机器，所以如果有读者觉得这种路径太繁琐/太慢热的话，本系列恐怕不适合你。无妨——优秀的 OS Tutorial 到处都是，相信读者稍微检索一下即可找到。\n而如果你是那部分还没被劝退的读者的话——欢迎登机，祝旅途愉快。\n背景知识 鉴于本系列是 OS 编写入门教程，而不是编程入门教程，我会假定读者具有以下背景知识：\n 以 C 语言编写程序的能力。本教程中绝大部分内容会用 C 语言实现，故而假定读者具有理解示例，以及自行补足或修改示例的能力。（另，别跟我推销 Rust，也别问我为什么不接受推销。） 对计算机系统组成的基本概念。OS 不止是 HAL，但 OS 通常需要实现一个 HAL。在使用硬件之前显然需要对硬件有概念。 OS 相关的基本理论。当然本系列并不要求读者成为 OS 专家，但没有理论的引导我们只会晕头转向，所以基础的理论知识也是必要的。  以上列表我会随时补充。感到自己知识有所欠缺的读者，可以预先补足，或者随着我们的进度推进一道补足。\n参考资料 教程本身是有极限的，额外的参考资料必不可少。以下将会列出我本人认为有价值的材料，方便读者随时查阅：\n OSDev Wiki OS 开发相关的 wiki，上面零散地分布着大量实用而有价值的资料。十星推荐。 RISC-V 标准 RISC-V 体系的标准。在我们编写 RISC-V 上的程序的时候将会大量参考这些内容。 《AMD64 Architecture Programmer\u0026rsquo;s Manual》AMD 官方提供的 AMD64 参考手册。在我们进行 x86-64 移植的时候将会大量参考该手册。  以上列表我会随时补充。\n 闲话少叙，是时候开始干点实事了。下一话，你好，THE WORLD!\n",
    "ref": "/blog/operating-system/os-from-scratch-intro/"
  },{
    "title": "密码学，从入门到劝退：古典密码（上篇）",
    "date": "",
    "description": "",
    "body": "其之二 推古及今：古典密码与现代密码 与其他很多学科不同的是，始于70年代的现代密码学，并非是在古典密码学上平缓发展而来的学科，而是一次开天辟地式的飞跃。之所以说是“开天辟地式”，是因为我们直到那时候才开始真正体系化地运用数学手段对密码学建模。密码学的这个飞跃大概可以说是到来得惊人地晚。\n而若以现代密码学的眼光回首望去，在这之前的古典密码学时代（哪怕是不到一百年前的20世纪初期），相比之下可谓是茹毛饮血——那时候的攻防手段基本还是基于语言文本的分析，而非如现代密码学一般基于信息论、离散概率以及其他数学手段。因为没有衡量安全性的手段，古典密码学里自然也无从对加密算法进行数学层面上的安全分析，加解密攻防不可避免地变成了猫鼠游戏式的勾心斗角。\n但即便如此，认真回顾这个持续了数千年的古典时代也是极有价值的。以史为鉴，将能让我们更为清晰地认知到加密算法所面对的威胁，以及现代密码学所提供的数学手段的宝贵。\n因此，虽说有老生常谈之嫌，本文仍将迅速地带领读者过一遍几种典型的古典密码。\n其之二甲 以史为鉴：古典密码（上篇） 一点背景知识：术语科普 名不正则言不顺。在正式进行古典密码的科普之前，我们需要先储备点基础的密码学术语。\n 密码（Cipher）：进行加密或解密的算法。注意此语境下的密码为 Cipher 的翻译，而非通常汉语口语中由用户输入的 Password。 密钥（Key）：一串保密信息，用于指导密码（Cipher）对原文及密文进行变换。 明文（Plaintext）：未经加密的原始消息。 密文（Ciphertext）：明文经加密算法变换后的产物。 COA，惟密文攻击（Ciphertext only Attack）：最严格的攻击模型。假定攻击者只能获得加密后的密文。此时攻击者的目标通常是获得明文，以及密钥；但在特定情况下，即使攻击者无法获得完整的明文，只要能得到关于明文的更多信息，也可算作成功。 KPA，已知明文攻击（Known Plaintext Attack）：假定攻击者能够获得明文和与之对应的密文的攻击模型。此时攻击者的目标通常是获得密钥。 CPA，选中明文攻击（Chosen Plaintext Attack）：假定攻击者能够自选任意明文，并获得对应密文的攻击模型。此时攻击者的目标通常是获得密钥。 CCA，选中密文攻击（Chosen Ciphertext Attack）：假定攻击者能够自选任意明文，并获得对应解密后的明文的攻击模型。此时攻击者的目标通常是获得密钥。  注意以上名词并非局限于古典密码学——不如说这些名词在现代密码学里会被更广泛地应用。\n在明确词义之后，我们终于可以开始讨论古典密码了。而最适合打头阵的，当然是替换密码。\n替换密码 谈到“密码”二字，绝大部分人的第一反应恐怕都是替换密码。这东西原理很简单：设定一张替换表，其中每一个字母都会被一一映射到另一个字母上；加密时将明文中每一个字符按照映射替换成对应的字母，解密则只是简单地逆向映射。\n顺嘴一提，我们可以将这个映射表看作密钥，只要能得到它，攻击便宣告成功。\n这东西安全度如何呢？按照我们上面提到的四种攻击模型分别讨论一下：\nCPA 以及 CCA：显然，无论我们手里的神谕机（Oracle）是加密神谕还是解密神谕，我们都只需要把所有字母灌进去，立刻就可以得到完整的映射表，不费吹灰之力。\nKPA：取决于能够获得的明文长度，以及明文中不同字母的种类，我们至少能获得映射表的一部分。对于那些字母表不大的语言来说，恐怕不需要多长的明文就足够我们推出整张映射表。\nCOA：这里需要我们稍微动点脑筋。假设明文的语言已知的话，我们可以采用一点统计手段：大部分自然语言的字母出现概率并不随机。以英语为例，e 出现的概率会是最高的，所以只需要统计出密文中出现概率最高的字母，我们便可以大概率确定它与 e 互相对应。其他字母也可以根据明文的语言特征分析出来。具体的例子因为过于经典已经在各种密码学教程中烂大街了，在这里我不再赘述。\n显然，替换密码的安全度并不高。\n凯撒密码及其变体 严格来说，凯撒密码其实是更弱一些的替换密码，所以对于替换密码的攻击只会对凯撒密码更有效。不过鉴于凯撒密码实际上我们之后将要介绍的不少其他密码的基础构造之一，这里我还是把它单独拎出来讲一下。\n凯撒密码的构造更为简单：将明文的每个字符按字母表顺序后移三位，即可得到密文。但仅仅如此的话，凯撒密码本身并不足以成为我们所讨论的密码（Cipher）：它没有密钥。这也是为什么本节的标题强调了“及其变体”：我们可以将这个构造略微扩展，令原本的后移三位变为后移 k 位，此时这里的 k 便可被视作密钥。\n显然，要破解凯撒密码，我们只需要推出 k；而要推出 k，只需要推断出明文中任意一个字母于密文中所对应的字母，二者的距离即为 k。鉴于其本质仍是替换密码，运用针对替换密码的攻击手段推出密钥轻而易举。\n能否对这个构造略微修改，使得它变得更加安全呢？\n维吉尼亚密码 一点花边：维吉尼亚密码的名称来源于 Blaise de Vigenère(1523-1596)，但现今已知的对该密码的最早论述实际由 Giovan Battista Bellaso 于1553给出。\n以英语为例，我先简单介绍一下维吉尼亚密码：\n维吉尼亚密码的密钥是一个单词（或者说，一串固定长度的文本）。这里我们先选用一个充满酸味的密钥，\u0026ldquo;LEMON\u0026rdquo;。\n给出一段任意长度的文本，我们先将明文字母和密钥对齐地写在上下两行。若密钥长度不足，则循环密钥补齐。例如，若我们需要加密 \u0026ldquo;ATTACKATDAWN\u0026rdquo;:\n然后，我们将明文中的每一个字母循环后移“密钥中对应字母的序数”位，（换言之，若密钥中对应字母是A，则后移0位；若密钥中对应字母是 B，则后移1位，依此类推）：\n以 C 语言实现的话：\n/* Assume ASCII */ char encrypt_char(char c_plaintext, char c_key) { return (c_plaintext - \u0026#39;A\u0026#39; + (c_key - \u0026#39;A\u0026#39;)) % 26 + \u0026#39;A\u0026#39;; } /* Assume `out` has enough capacity to hold ciphertext */ void encrypt(char *out, const char *plaintext, const char *key) { size_t key_size = strlen(key), plaintext_size = strlen(plaintext); for (size_t i = 0; i \u0026lt; plaintext_size; ++i) { out[i] = encrypt_char(plaintext[i], key[i % key_size]); } out[plaintext_size] = \u0026#39;\\0\u0026#39;; } 花点时间理解下这东西。好了吗？你能想出破解方法吗？\n想不出来也没关系，毕竟这东西发明出来以后花了三百年才被破解。不过如果你还不想太早放弃的话，我可以给点提示：我们可以先假定密钥长度已知。\n下有答案，不想被糊一脸的话别急着下滑。\n 维吉尼亚密码的破解 假定密钥长度已知（例如，在刚才的例子里密钥长度是5），我们可以先把密文按照密钥长度分组。比如上例中，我们可以每五个字符分一组：\n然后我们将密文竖着看。注意到什么了吗？\n没错，每个竖行都是用同一个字母加密的，故而位移相同。也就是说，每一个竖行都是一串经过凯撒加密的密文。此时破解方法已经呼之欲出了：我们可以对每个竖行分别应用一次针对凯撒加密的攻击，然后即可反推出密钥。\n如果密钥长度未知呢？那也不难，我们只需要先假定密钥长度为1，进行攻击尝试；若无法得到有意义的明文，则再假定密钥长度为2，进行攻击尝试，依次穷举下去，直到我们得到有意义的密文。在仅有纸笔的时代密钥长度通常并不长，所以这个过程其实没有想象得那么耗时。\n惊人地简单，是不是？\n 到这里我们可以先休息一下，因为接下来我们要介绍的东西值得单独分出一篇博文：转子加密机。这一类加密机中最著名的恐怕便是二战时纳粹德国使用的 Enigma 密码机了。尽管与之相关的神话数不胜数，但我将要演示的，其实是 Enigma 以如今的眼光来看，安全性到底低到什么程度。\n下一话，Enigma 之死！\n",
    "ref": "/blog/cryptography/cryptography-introduction/classic-cryptography-1/"
  },{
    "title": "密码学，从入门到劝退：引论",
    "date": "",
    "description": "",
    "body": "密码学——当下被广泛应用，却又被广泛忽视的学科。在这个 HTTPS / SSH / WPA / 某种工具（咳咳，你懂） 满天飞的时代，说你每分钟都在应用密码学大概不是什么夸张。但另一方面，有很大一部分人，包括那些在生产环境中应用密码学组建构建系统的人，可以说连密码学的常识都没有。\n惭愧地说，我其实也是其中一员。在 ProtonMail 勾起我对密码学的兴趣之前，我甚至干出过拿$$ SHA256(Password | Salt) $$当密码 Hash 存在数据库里的蠢事（别动歪心思，这东西现在已经不在线上运行了）；而且我毫不怀疑部分读者可能还没看出来这有什么问题。\n不要紧。这个系列的目标正是普及密码学常识——至少是在我力所能及范围内的常识。\n动机，以及本系列的目标 我记得之前看到过一个花边新闻（不幸，现在我找不到来源了）：\n一位密码学家好奇 WebAssembly 在密码学意义上的安全性，于是在推上向 WA 的某个核心开发者询问 WebAssembly 的时间恒定性相关考量。他得到的回应是一个振聋发聩的问句：“旁道是什么？”\n我无意指责这位不知道旁道的开发者。但这确实折射出一个严重的问题：我们的从业者对密码学常识的缺乏实际相当严重。这正是启发我创作本系列的原因。\n读者要注意的是，作为“密码学劝退”科普而非“密码学”科普，我并不打算在本系列里深入讲解密码学的知识，特别是密码学的数学内容。入门密码学并非本系列的目标；恰恰相反，本系列的目标是培养读者对于密码学的敬畏之心，同时让读者无需成为密码学家也能较安全地应用现有的密码学组件。\n更明确地说，在读完本系列以后，读者应当具备如下知识：\n 知道古典密码学和现代密码学的差异，以及现代密码学的安全保证。 对常见的密码学算法及实现有所了解，明确它们的能力和限制。 明白为什么密码学领域尤其不鼓励自造轮子。  选择这样的角度，一方面是因为本人的密码学水平远未达到可以进行教学的程度，另一方面则是因为密码学界并不缺乏专业的教材。故而任何有志于密码学研究的读者，应当做好接下来需要自行寻找其他教材提升的准备。\n关于“劝退”二字  Anyone, from the most clueless amateur to the best cryptographer, can create an algorithm that he himself can\u0026rsquo;t break. It\u0026rsquo;s not even hard. What is hard is creating an algorithm that no one else can break, even after years of analysis. \u0026ndash; Bruce Schneier, 1998 如上所言，本系列的目标之一是令读者知晓“为何密码学领域尤其不鼓励自造轮子”。实际上这是本系列的重中之重。\n无论直接还是间接，我自己见过的试图自造轮子的人简直黄河沙数。而其中大部分人不是已经悲剧，就是正在通往悲剧的路上。常见的表现有以下几种（顺序无关）：\n 搞了一套自造算法，试了一下发现自己破解不了，于是便认为安全。 搞了一套自造算法，觉得只要不把算法细节公布出来，自己就是安全的。 拿一些老旧的算法(RC4/DES/SHA1 等等)互相套娃，然后觉得自己的设计比这些组件更安全。 用 C/Java/JS/其他什么高级语言写了一套密码学算法实现，写了几个单元测试，发现输入输出没什么问题，然后就认定实现正确。  上表远非穷尽，而我也不知道列出来的这几个常见错误已经让多少人中枪；不过如果你未经密码学训练，而又曾经自信满满地实现过一套安全系统，那么你该当心了：本系列正是用来击碎你的自信的。当你知道现实中的攻击未必只是盯着一段密文反推原文，当你知道数学上绝对安全的算法一旦变成实现就多出了成千上万个漏洞以后，懵懂时期的安全感还能保持住几分呢？至少当我回头看我之前用上密码学的程序的话，我觉得那些全是我的黑历史。\n引论到此为止。这篇文章中提到的内容，我都会在之后尽可能地展开讲述。所以若以上内容能够激起你的兴趣的话，Stay tuned。\n 下一话，古典密码，堂堂连载！\n",
    "ref": "/blog/cryptography/cryptography-introduction/intro/"
  },{
    "title": "「译」Telegram，又曰“退下，让老子的数学PhD来！”",
    "date": "",
    "description": "",
    "body": " 译注 原文见《Telegram, Aka \u0026ldquo;Stand back, we have Math PhDs!\u0026quot;》。该文发表于2013年，不少内容或许已经过期，故仅供参考。\n   免责声明 本文如今已十分古老，未必能反应 Telegram 协议于时下的情况。这期间已经有了不少其他研究进展，故而此文不应当被用作你选择加密聊天软件的依据。虽说如此，就我个人而言，我依然认为 Telegram 的加密系统很古怪，并且他们对此的洗地言论站不住脚。如果你想要我推荐一个加密聊天软件：找一套基于 Axolotl/Signal 协议的体系。这套协议设计良好，且已经过大量审查。 Signal 和 WhatsApp，以及一些其他的程序都使用了这套协议。\n 本文是本系列中第二篇介绍奇怪加密 App 的，对象是最近甚嚣尘上的 Telegram。\n据他们网站所言，Telegram “基于云计算而且大量运用加密”。它有多安全？\n 非常安全。我们的技术基于一套新协议，名为MTProto，由我们自己的专家研发，并运用了经过时间考验的加密算法。目前而言，你在 Telegram 上的消息泄漏的最大风险是你妈从你背后看你屏幕。其他的风险我们都能搞定。\n (引自他们的 FAQ)\n嗯，非常安全，他们自己这么说的。\n行，那我们就来看看到底多安全。\n目前可以公开的安全情报 他们的网站上发布了协议的细节。他们其实可以多画些示意图，而不是写一堆纯文字，不过现在这样也算能读。还有个拿 Java 写的开源协议实现。这算个优点。\n关于他们的团队（嗯，我还记得我说过不搞诉诸人身，但毕竟他们一直在吹这点）：\n Telegram 背后的团队，由 Nikolai Durov 牵头，共计六个 ACM 冠军组成，其中半数都是数学PhD。他们花了两年时间来设计当前的 MTProto。虽说学历未必代表能力，但至少能说明这套协议是海量专家精确计算的结果（原文：result of thougtful and prolonged work of professionals）\n （来自 Hacker News）\n他们不是密码学家，但他们有数学学术背景。好耶！\n那么，整个体系架构长什么样？**基本上就是世界各地放几台服务器，在客户端之间转发信息。**身份验证只做在客户端和服务端之间，而不是客户端之间点对点验证。客户端和服务端之间有加密，但用的不是TLS（而是一些自制的协议）。加密可以端对端进行，但因为没有身份验证，所以服务器可以进行中间人攻击。\n本质而言，他们的威胁模型就只是“信任服务器”。在公网上传输的内容可能被安全加密了，但我们毕竟无从了解他们的服务器间通信细节，也无法得知他们的数据存储方案。以今天的眼光看来，这套东西既没意思，又昭示着不安全和粗心。类似的系统可以参考 Lavabit 或者 iMessage。这套系统并不能阻止执法部门的监听或者服务器渗透。更糟糕的：你都没法检测到和你聊天对象之间的中间人攻击。\n我可以就此收手，但这样就没意思了。真正的乐子其实常在他们的加密设计里。这些设计粗看起来似乎合理，但对加密算法的选择既奇怪又不安全，而且每一个设计都无谓地选择了最复杂的那种。\n网络协议 网络协议有两个阶段：密钥交换和通信。\n密钥交换过程会向服务器注册一个设备。为此他们自己搞了一套协议，理由是 TLS 太慢而且太复杂。有一说一，确实：TLS 需要在客户端和服务器间跑两个来回 (round trip) 才能完成密钥交换。而且还需求一个 x509 证书，以及一套 RSA 或者 DSA 这种公钥加密算法，最终还需要走一趟 Diffle-Hellman 密钥交换算法。\nTelegram 大幅简化了这个过程（迫真），只需要三个 RT，用上 RSA、 AES-IGE（某个没其他人用的奇怪加密模式），以及 DH 密钥交换，同时还有一套工作量证明（客户端得因数分解个数字，估计是个 DoS 防护措施）。另外，他们还用了一套土制算法来从服务器和客户端生成的 nonce 导出 AES 密钥和 IV（ server_nonce 在通信过程中是明文传输的）：\nkey = SHA1(new_nonce + server_nonce) + substr(SHA1(server_nonce + new_nonce), 0, 12); iv = substr(SHA1(server_nonce + new_nonce), 12, 8)+ SHA1(new_nonce + new_nonce) + substr (new_nonce, 0, 4); 注意 AES-IGE 是不带认证的。所以他们自行实现了完整性验证，方法是简单地对原文取个 SHA1 （没错，甚至都没用个正经的 MAC），然后把 Hash 结果和原文一起加密（没错，这就是个迫真 MAC-then-Encrypt）。\n最终的 DH 交换会创建一个储存在服务端和客户端（搞不好还是明文存储）的认证密钥。\n我实在难以理解他们为什么要搞一套这么复杂的协议。他们本来可以这么搞：客户端生成一对密钥，用服务端的公钥加密客户端的公钥，和 nonce 一起发给服务端，然后服务端把用客户端公钥加密过的 nonce 发回来。简单有效。而且这样还可以向客户端提供公钥，实现端对端加密。\n至于通信阶段：他们用了一套服务端加盐、消息 ID 和消息计数器的组合来阻止重放攻击。有趣的是，他们的消息密钥是用 SHA1 值的低128位组成的。这个消息密钥用明文传输，所以如果你监听到了消息头，那么此处应有巨大多信息泄漏。\n用来加密消息的 AES 密钥（还是 IGE 模式下的 AES）是这么生成的：\n如下是从 auth_key 和 msg_key 计算 aes_key 和 aes_iv 的算法：\nsha1_a = SHA1(msg_key + substr(auth_key, x, 32)); sha1_b = SHA1(substr(auth_key, 32+x, 16) + msg_key + substr(auth_key, 48+x, 16)); sha1_с = SHA1(substr(auth_key, 64+x, 32) + msg_key); sha1_d = SHA1(msg_key + substr(auth_key, 96+x, 32)); aes_key = substr(sha1_a, 0, 8) + substr(sha1_b, 8, 12) + substr(sha1_c, 4, 12); aes_iv = substr(sha1_a, 8, 12) + substr(sha1_b, 0, 8) + substr(sha1_c, 16, 4) + substr (sha1_d, 0, 8); 其中，在客户端给服务端的消息中 \\(x = 0\\)，而服务端给客户端的消息中\\(x = 8\\)。\n因为 auth_key 是永久的，而消息密钥只依赖于服务端提供的盐（24小时一换）、会话 ID（估计是永久的，不过可能会被服务端忘掉）以及消息的开始部分，可能很多消息都会生成同样的消息密钥。没错，很多消息会共享同样的 AES 密钥和 IV。编辑：据 Telegram 的评论所言，每条消息的 AES 密钥和 IV 都是不同的。但还是那句话，根据消息内容来生成密钥和 IV 是个及其糟糕的设计。这二者必须从 CSPRNG 生成，和加密内容保持无关。\n编辑2：新的协议示意图澄清了密钥是由一个很弱的密钥导出算法推出来的，而且部分内容直接明文传输。这里大概有不少可以拿统计分析搞事情的地方。\n编辑3：行吧，如果你把同一条消息发两遍（在一天当中，因为服务端生成的盐能活24小时），密钥和 IV 会是一样的，而且密文也会是一样的。这是个正儿八经的安全漏洞。通常的解决方式是常换 IV （即使是 WEP 这样的破烂协议都知道这么干）而且常换密钥（也即 TLS 或者 OTR 里的前向安全性）。消息原文里包含一个（时间相关）的消息 ID 以及自增的消息序列号，所以客户端不会接受重放的消息，或者太旧的消息。\n编辑4：有人在端对端聊天中找到了一个漏洞。从 DH 算法生成出来的密钥会和服务端提供的 nonce 结合：key = (pow(g_a, b) mod dh_prime) xor nonce。这样，服务端就可以通过在两个客户端间生成同样的密钥，以此进行中间人攻击，让密钥验证失效。Telegram 已经更新了协议描述，打算修复这个漏洞。（这个 nonce 的引入是为了修复某些移动设备上的 RNG 问题）。\n 译注 我觉得这个洗地站不住脚。RNG 缺陷可以有多种方式解决：比如 EdDSA 演示实现中将128个随机字节 Hash 到 32个，以此避免暴露 RNG 原始输出防止逆推 RNG 状态。TG 这个解决方法在我看来非蠢即坏——在加密相关问题上我倾向于假定后者。\n 正经说，我从来没见过有人用 MAC 来生成加密用密钥的。就算你想埋后门，也不用埋得这么明显啊……\n结论：快跑。里面没有什么全新发明，而且他们还通过自行组合 RSA、AES-IGE、纯 SHA1 完整性验证、MAC后加密、和自制 KDF 引入了一堆自制安全漏洞。比起 Telegram，你更应该用个有名的而且被审计过的协议，比如说 OTR （可用于 IRC 及 Jabber ），或者 TextSecure 的 Axolotl key ratcheting。\n",
    "ref": "/blog/cryptography/telegram-aka-stand-back-we-have-math-phds/"
  }]
