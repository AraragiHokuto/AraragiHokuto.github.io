<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>operating-system on 瞳</title>
    <link>https://blog.hitomi.dev/categories/operating-system/</link>
    <description>Recent content in operating-system on 瞳</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 24 Dec 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://blog.hitomi.dev/categories/operating-system/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>初等屠龙技：阿库娅也能看懂的 OS 编写入门 序</title>
      <link>https://blog.hitomi.dev/blog/operating-system/os-from-scratch-intro/</link>
      <pubDate>Thu, 24 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.hitomi.dev/blog/operating-system/os-from-scratch-intro/</guid>
      <description>其之一 引 如是我闻：程序员有三大浪漫，曰OS，曰CG，曰编译器。虽说引用*乎上业界爱抖露的言论是个高风险行为，不过我还是打算拿这句话作为开篇之语——反正这是我自己的博客，管他那么多。
我还记得小学三年级时的自己。那时候我还是个对计算机充满好奇的熊孩子，脑袋里充斥着一行代码没读过的外行人对编程的幻想。当时我听说 Linux 和 Windows 都是用 C 写的，于是误以为花个一两年的时间把 C 入了门，就足以写出一个操作系统来自娱自乐——我到现在还能记得当时我幻想中的那个自制 OS 的 BIOS 式蓝色背景文本 GUI（现在回首，在 UI 的设想上我还真是意外地有自知之明，没幻想一个华丽的3D 桌面出来）。
当然不必说，买回来一本 VB 教程和一本国内大学 C++ 教材的我自然是连门都没碰到，甚至连编程本身也没学到几分。真正要入门 OS 开发，那还得等到初二的时候有人给我指了路，我才跟着一个相对实用的教程写了半个内核出来。
关于我自己的闲话就到此为止。至于提笔编写这个教程的动机——如前文所述——是浪漫。虽说既然是如此普遍的浪漫，教程自然不会少，但我总觉得编写玩具 OS 可以采取一个不那么实用向的角度（不会真的有人觉得自己花一个月就能打败 Windows&amp;amp;Linux&amp;amp;macOS 吧？）。然而不幸，我所能找到的 OS Tutorial 几乎都始于从 0x7c00 启动开始读扇区，或者从 multiboot 启动之后开始往 0xb8000 写字符显示 VGA 文本。
这无可非议。毕竟写 OS 总得让人有点成就感，而在自己的 x86 机器上跑一个能往屏幕上吐出东西的裸机程序大概是获得成就感的最快方式了。但我还是觉得不高兴：既然都已经放弃实用性追求浪漫了，身为活在新世纪的第二个十年的年轻人，我们何不抛开这些历史的苟且，搞些更优雅更浪漫的东西出来呢？
正因如此，我打算在本系列中采取一个不那么寻常的路子。我们将首先实现一个 RISC-V 上的类 Unix 操作系统，一直到能跑起一个基础的 shell 为止，但我们并不止于此；之后，我们还要把我们这个玩具 OS 移植到 x86-64 上。
这种路径会带来几个好处：
 因为我们已经预定了多体系支持，这便要求我们在编写内核的时候留个心眼，而不会满足于平台相关的七拼八凑。 不同体系之间的对比能更加明显地凸显出哪些部分是操作系统的本质，哪些部分是与体系交互的抽象层。我个人希望这种概念上的明晰能让入门读者受益更多。 众所周知，x86 的臃肿和混乱可谓臭名昭彰。从 RISC-V 上开始能让我们更快地真正开始编写我们的操作系统，而不用花大力气对付实模式/保护模式/长模式，以及其他那堆历史遗留的东西。  当然，考虑到大部分读者还在用着 x86 的机器，所以如果有读者觉得这种路径太繁琐/太慢热的话，本系列恐怕不适合你。无妨——优秀的 OS Tutorial 到处都是，相信读者稍微检索一下即可找到。</description>
    </item>
    
  </channel>
</rss>