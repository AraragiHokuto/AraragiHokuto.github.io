<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>cryptography on 瞳</title>
    <link>https://blog.hitomi.dev/categories/cryptography/</link>
    <description>Recent content in cryptography on 瞳</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 24 Dec 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://blog.hitomi.dev/categories/cryptography/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>密码学，从入门到劝退：古典密码（上篇）</title>
      <link>https://blog.hitomi.dev/blog/cryptography/cryptography-introduction/classic-cryptography-1/</link>
      <pubDate>Thu, 24 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.hitomi.dev/blog/cryptography/cryptography-introduction/classic-cryptography-1/</guid>
      <description>其之二 推古及今：古典密码与现代密码 与其他很多学科不同的是，始于70年代的现代密码学，并非是在古典密码学上平缓发展而来的学科，而是一次开天辟地式的飞跃。之所以说是“开天辟地式”，是因为我们直到那时候才开始真正体系化地运用数学手段对密码学建模。密码学的这个飞跃大概可以说是到来得惊人地晚。
而若以现代密码学的眼光回首望去，在这之前的古典密码学时代（哪怕是不到一百年前的20世纪初期），相比之下可谓是茹毛饮血——那时候的攻防手段基本还是基于语言文本的分析，而非如现代密码学一般基于信息论、离散概率以及其他数学手段。因为没有衡量安全性的手段，古典密码学里自然也无从对加密算法进行数学层面上的安全分析，加解密攻防不可避免地变成了猫鼠游戏式的勾心斗角。
但即便如此，认真回顾这个持续了数千年的古典时代也是极有价值的。以史为鉴，将能让我们更为清晰地认知到加密算法所面对的威胁，以及现代密码学所提供的数学手段的宝贵。
因此，虽说有老生常谈之嫌，本文仍将迅速地带领读者过一遍几种典型的古典密码。
其之二甲 以史为鉴：古典密码（上篇） 一点背景知识：术语科普 名不正则言不顺。在正式进行古典密码的科普之前，我们需要先储备点基础的密码学术语。
 密码（Cipher）：进行加密或解密的算法。注意此语境下的密码为 Cipher 的翻译，而非通常汉语口语中由用户输入的 Password。 密钥（Key）：一串保密信息，用于指导密码（Cipher）对原文及密文进行变换。 明文（Plaintext）：未经加密的原始消息。 密文（Ciphertext）：明文经加密算法变换后的产物。 COA，惟密文攻击（Ciphertext only Attack）：最严格的攻击模型。假定攻击者只能获得加密后的密文。此时攻击者的目标通常是获得明文，以及密钥；但在特定情况下，即使攻击者无法获得完整的明文，只要能得到关于明文的更多信息，也可算作成功。 KPA，已知明文攻击（Known Plaintext Attack）：假定攻击者能够获得明文和与之对应的密文的攻击模型。此时攻击者的目标通常是获得密钥。 CPA，选中明文攻击（Chosen Plaintext Attack）：假定攻击者能够自选任意明文，并获得对应密文的攻击模型。此时攻击者的目标通常是获得密钥。 CCA，选中密文攻击（Chosen Ciphertext Attack）：假定攻击者能够自选任意明文，并获得对应解密后的明文的攻击模型。此时攻击者的目标通常是获得密钥。  注意以上名词并非局限于古典密码学——不如说这些名词在现代密码学里会被更广泛地应用。
在明确词义之后，我们终于可以开始讨论古典密码了。而最适合打头阵的，当然是替换密码。
替换密码 谈到“密码”二字，绝大部分人的第一反应恐怕都是替换密码。这东西原理很简单：设定一张替换表，其中每一个字母都会被一一映射到另一个字母上；加密时将明文中每一个字符按照映射替换成对应的字母，解密则只是简单地逆向映射。
顺嘴一提，我们可以将这个映射表看作密钥，只要能得到它，攻击便宣告成功。
这东西安全度如何呢？按照我们上面提到的四种攻击模型分别讨论一下：
CPA 以及 CCA：显然，无论我们手里的神谕机（Oracle）是加密神谕还是解密神谕，我们都只需要把所有字母灌进去，立刻就可以得到完整的映射表，不费吹灰之力。
KPA：取决于能够获得的明文长度，以及明文中不同字母的种类，我们至少能获得映射表的一部分。对于那些字母表不大的语言来说，恐怕不需要多长的明文就足够我们推出整张映射表。
COA：这里需要我们稍微动点脑筋。假设明文的语言已知的话，我们可以采用一点统计手段：大部分自然语言的字母出现概率并不随机。以英语为例，e 出现的概率会是最高的，所以只需要统计出密文中出现概率最高的字母，我们便可以大概率确定它与 e 互相对应。其他字母也可以根据明文的语言特征分析出来。具体的例子因为过于经典已经在各种密码学教程中烂大街了，在这里我不再赘述。
显然，替换密码的安全度并不高。
凯撒密码及其变体 严格来说，凯撒密码其实是更弱一些的替换密码，所以对于替换密码的攻击只会对凯撒密码更有效。不过鉴于凯撒密码实际上我们之后将要介绍的不少其他密码的基础构造之一，这里我还是把它单独拎出来讲一下。
凯撒密码的构造更为简单：将明文的每个字符按字母表顺序后移三位，即可得到密文。但仅仅如此的话，凯撒密码本身并不足以成为我们所讨论的密码（Cipher）：它没有密钥。这也是为什么本节的标题强调了“及其变体”：我们可以将这个构造略微扩展，令原本的后移三位变为后移 k 位，此时这里的 k 便可被视作密钥。
显然，要破解凯撒密码，我们只需要推出 k；而要推出 k，只需要推断出明文中任意一个字母于密文中所对应的字母，二者的距离即为 k。鉴于其本质仍是替换密码，运用针对替换密码的攻击手段推出密钥轻而易举。
能否对这个构造略微修改，使得它变得更加安全呢？
维吉尼亚密码 一点花边：维吉尼亚密码的名称来源于 Blaise de Vigenère(1523-1596)，但现今已知的对该密码的最早论述实际由 Giovan Battista Bellaso 于1553给出。
以英语为例，我先简单介绍一下维吉尼亚密码：
维吉尼亚密码的密钥是一个单词（或者说，一串固定长度的文本）。这里我们先选用一个充满酸味的密钥，&amp;ldquo;LEMON&amp;rdquo;。
给出一段任意长度的文本，我们先将明文字母和密钥对齐地写在上下两行。若密钥长度不足，则循环密钥补齐。例如，若我们需要加密 &amp;ldquo;ATTACKATDAWN&amp;rdquo;:</description>
    </item>
    
    <item>
      <title>密码学，从入门到劝退：引论</title>
      <link>https://blog.hitomi.dev/blog/cryptography/cryptography-introduction/intro/</link>
      <pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.hitomi.dev/blog/cryptography/cryptography-introduction/intro/</guid>
      <description>密码学——当下被广泛应用，却又被广泛忽视的学科。在这个 HTTPS / SSH / WPA / 某种工具（咳咳，你懂） 满天飞的时代，说你每分钟都在应用密码学大概不是什么夸张。但另一方面，有很大一部分人，包括那些在生产环境中应用密码学组建构建系统的人，可以说连密码学的常识都没有。
惭愧地说，我其实也是其中一员。在 ProtonMail 勾起我对密码学的兴趣之前，我甚至干出过拿$$ SHA256(Password | Salt) $$当密码 Hash 存在数据库里的蠢事（别动歪心思，这东西现在已经不在线上运行了）；而且我毫不怀疑部分读者可能还没看出来这有什么问题。
不要紧。这个系列的目标正是普及密码学常识——至少是在我力所能及范围内的常识。
动机，以及本系列的目标 我记得之前看到过一个花边新闻（不幸，现在我找不到来源了）：
一位密码学家好奇 WebAssembly 在密码学意义上的安全性，于是在推上向 WA 的某个核心开发者询问 WebAssembly 的时间恒定性相关考量。他得到的回应是一个振聋发聩的问句：“旁道是什么？”
我无意指责这位不知道旁道的开发者。但这确实折射出一个严重的问题：我们的从业者对密码学常识的缺乏实际相当严重。这正是启发我创作本系列的原因。
读者要注意的是，作为“密码学劝退”科普而非“密码学”科普，我并不打算在本系列里深入讲解密码学的知识，特别是密码学的数学内容。入门密码学并非本系列的目标；恰恰相反，本系列的目标是培养读者对于密码学的敬畏之心，同时让读者无需成为密码学家也能较安全地应用现有的密码学组件。
更明确地说，在读完本系列以后，读者应当具备如下知识：
 知道古典密码学和现代密码学的差异，以及现代密码学的安全保证。 对常见的密码学算法及实现有所了解，明确它们的能力和限制。 明白为什么密码学领域尤其不鼓励自造轮子。  选择这样的角度，一方面是因为本人的密码学水平远未达到可以进行教学的程度，另一方面则是因为密码学界并不缺乏专业的教材。故而任何有志于密码学研究的读者，应当做好接下来需要自行寻找其他教材提升的准备。
关于“劝退”二字  Anyone, from the most clueless amateur to the best cryptographer, can create an algorithm that he himself can&amp;rsquo;t break. It&amp;rsquo;s not even hard. What is hard is creating an algorithm that no one else can break, even after years of analysis.</description>
    </item>
    
    <item>
      <title>「译」Telegram，又曰“退下，让老子的数学PhD来！”</title>
      <link>https://blog.hitomi.dev/blog/cryptography/telegram-aka-stand-back-we-have-math-phds/</link>
      <pubDate>Wed, 28 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.hitomi.dev/blog/cryptography/telegram-aka-stand-back-we-have-math-phds/</guid>
      <description>译注 原文见《Telegram, Aka &amp;ldquo;Stand back, we have Math PhDs!&amp;quot;》。该文发表于2013年，不少内容或许已经过期，故仅供参考。
   免责声明 本文如今已十分古老，未必能反应 Telegram 协议于时下的情况。这期间已经有了不少其他研究进展，故而此文不应当被用作你选择加密聊天软件的依据。虽说如此，就我个人而言，我依然认为 Telegram 的加密系统很古怪，并且他们对此的洗地言论站不住脚。如果你想要我推荐一个加密聊天软件：找一套基于 Axolotl/Signal 协议的体系。这套协议设计良好，且已经过大量审查。 Signal 和 WhatsApp，以及一些其他的程序都使用了这套协议。
 本文是本系列中第二篇介绍奇怪加密 App 的，对象是最近甚嚣尘上的 Telegram。
据他们网站所言，Telegram “基于云计算而且大量运用加密”。它有多安全？
 非常安全。我们的技术基于一套新协议，名为MTProto，由我们自己的专家研发，并运用了经过时间考验的加密算法。目前而言，你在 Telegram 上的消息泄漏的最大风险是你妈从你背后看你屏幕。其他的风险我们都能搞定。
 (引自他们的 FAQ)
嗯，非常安全，他们自己这么说的。
行，那我们就来看看到底多安全。
目前可以公开的安全情报 他们的网站上发布了协议的细节。他们其实可以多画些示意图，而不是写一堆纯文字，不过现在这样也算能读。还有个拿 Java 写的开源协议实现。这算个优点。
关于他们的团队（嗯，我还记得我说过不搞诉诸人身，但毕竟他们一直在吹这点）：
 Telegram 背后的团队，由 Nikolai Durov 牵头，共计六个 ACM 冠军组成，其中半数都是数学PhD。他们花了两年时间来设计当前的 MTProto。虽说学历未必代表能力，但至少能说明这套协议是海量专家精确计算的结果（原文：result of thougtful and prolonged work of professionals）
 （来自 Hacker News）
他们不是密码学家，但他们有数学学术背景。好耶！
那么，整个体系架构长什么样？**基本上就是世界各地放几台服务器，在客户端之间转发信息。**身份验证只做在客户端和服务端之间，而不是客户端之间点对点验证。客户端和服务端之间有加密，但用的不是TLS（而是一些自制的协议）。加密可以端对端进行，但因为没有身份验证，所以服务器可以进行中间人攻击。
本质而言，他们的威胁模型就只是“信任服务器”。在公网上传输的内容可能被安全加密了，但我们毕竟无从了解他们的服务器间通信细节，也无法得知他们的数据存储方案。以今天的眼光看来，这套东西既没意思，又昭示着不安全和粗心。类似的系统可以参考 Lavabit 或者 iMessage。这套系统并不能阻止执法部门的监听或者服务器渗透。更糟糕的：你都没法检测到和你聊天对象之间的中间人攻击。</description>
    </item>
    
  </channel>
</rss>